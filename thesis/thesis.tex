\documentclass[11pt,a4paper,oneside]{book}

\input{macros.tex}

\input{includes.tex}

\title{Constructive Formalization of Regular Languages}
\author{Jan-Oliver Kaiser}

\begin{document}
    \maketitle
    \tableofcontents
    
    \chapter{Introduction}

        \paragraph{} We aim to show that an extensive, yet elegant formalization of regular languages can be achieved in constructive type theory.

        \section{Recent work}
        
            \paragraph{} 
                There have been many publications on regular languages in recent years. Many of them investigate decidability of equivalence of regular languages, though there have also been new equivalence proofs regarding different characterizations of regular languages.

    \chapter{Coq, \ssreflect}

        \paragraph{}
            We decided to employ the Small Scale Reflection Extension (\textbf{\ssreflect}) for the \textbf{\coq} proof assistant. 
            The most important factors in this decision were \ssreflect's excellent support for finite types, list operations and graphs. \ssreflect{} also introduces many syntactic extensions that can often be used to shorten the bookkeeping overhead of proofs considerably.

    \chapter{Decidable Languages}

    \section{Definition}
        \paragraph{}
        An alphabet $\Sigma$ is finite a set of symbols. A word $w \in \Sigma^*$ is a finite concatenation of symbols from $\Sigma$, where $\,^*$ denotes the Kleene star. We will also consider the concatenation ($L_1 \cdot L_2 := \{w \cdot v\ \vert w \in L_1,  \in L_2\}$), and the boolean operations ($\cup$, $\cap$, $\neg$) on languages.
        A language $L$ is a set of words formed of symbols from an alphabet. 

        
        \paragraph{} We restrict all further discussion to decidable languages:
        \[
            \mathcal{L}_{dec} := \{ \, L \, \subseteq \, \Sigma^* \, 
                \vert \, \exists f \in \mathcal{R}. \, \forall x \in \Sigma^*. \, f(x) = 1 \Leftrightarrow  x \in L. \}
        \] 

        \paragraph{Observation} The decidable languages are closed under $\cdot, \,^*, \cup, \cap$ and $\neg$. This is easily seen by considering (non-empty) substrings for $\cdot$ and $\,^*$. The boolean operators can be applied directly to the decision functions.

        \section{Regular Languages}
        
        %\paragraph{} In our formalization, we consider three well-known characterizations of regular languages: \textbf{Regular expressions} (due to Stephen Cole Kleene \cite{KleeneNets}), \textbf{finite automata}, and the characterization derived from the \textbf{Myhill-Nerode theorem} (John Myhill, Anil Nerode \cite{Nerode1958}) 
    
            \paragraph{}
            The set of regular languages $REG$ is defined to be exactly those languages generated by the following recursive procedure
            \begin{itemize}
                \item
                    $\emptyset \in REG$, 
                \item
                    $\forall a \in \Sigma. \, \{a\} \in REG$, 
                \item
                    $\forall L_1, L_2 \in REG. \, L_1^* \in REG, \, L_1 \cup L_2 \in REG, \, L_1 \cdot L_2 \in REG$.
            \end{itemize}

            \paragraph{Observation} $REG$ is also closed under $\neg$ and $\cap$.


        \subsection{Regular Expressions}

                \paragraph{} 
                Regular expressions mirror the definition of regular languages very closely. We will consider extended regular expressions that include $\neg$, $\cap$ and $.$, which is a single-symbol wildcard. 
                %Regular expressions are finite expressions over an alphabet consisting of atomic expressions or subexpressions combined by operators. Every regular expressions has an associated language, either directly or by some combination of the subexpressions' languages.
                We take the implementation from Coquand and Siles's development (\cite{DBLP:conf/cpp/CoquandS11}), which is also based on \ssreflect and comes with helpful infrastructure for our proofs.

                \code{regexp}{Regular Expressions}{regexp_regular_expression}

                \subsection{Computing Language Membership}
                    \paragraph{}
                We make use of derivatives of regular expressions (\cite{DBLP:journals/jacm/Brzozowski64}) to compute if a word $w \in \Sigma^*$ is contained in $L \in REG$. Derivatives are themselves regular expressions and are computed in respect to a single input character. The derivative $der \,  r \, a$ of $r$ w.r.t. to $a$ is defined s.t. 
                \[
                    \forall w \in \Sigma^*. \, w \, \in \, \lang{der \, r \, a} \Leftrightarrow a\cdot w \, \in \, \lang{r}.
                \]
                A suitable implementation is provided by Coquand and Siles.

                \code{regexp_der}{Derivatives of Regular Expressions}{regexp_der}

                \paragraph{} 
                    Given the defining property of derivatives, we can easily see that a generalization of $der$ to words suffices to compute membership. We only need to check if the derivative w.r.t. to a given word accepts the empty word.

                %\code{regexp_wder}{}{regexp_wder}
                %\vspace{-0.4cm}
                \code{regexp_mem_der}{}{regexp_mem_der}

            

    \chapter{Finite Automata}
        \paragraph{} 
        Another way of characterizing $REG$ are finite automata. 
        We will show that the languages of finite automata are exactly $REG$. 
        Furhtermore, we will also derive a decision procedure for equivalence of regualar expressions.

        \section{Definition}
            A finite automaton is defined as a five-tuple of an alphabet $\Sigma$, state space $Q$, starting state $s_0 \in Q$, set of final states $F \subseteq Q$ and state-transition relation $\delta$. 
            We define a run of a word $w \in \Sigma^*$ on an automaton $(\Sigma, Q, s_0, F, \delta)$ as any sequence of states $\sigma$ s.t. $\forall i < \vert\sigma\vert-1. \, (\sigma_i, w_i, \sigma_{i+1}) \in \delta$.
            A word is accepted by an automaton if and only if there exists a run $\sigma$ s.t. $\sigma_0 = s_0 \, \wedge \, \sigma_{\vert\sigma\vert-1} \in F$.

            \subsection{Determinism and Non-Determinism}
                \paragraph{} 
                Finite automata can be non-deterministic in the sense that there exist multiple distinct runs for a word. This is the case if and only if $\delta$ is not functional. Our implementation very much mirrors the mathematical definition.

                \code{nfa}{Non-Deterministic Finite Automata}{automata_nfa}
                \code{nfa_accept}{}{automata_nfa_accept}
                \code{nfa_lang}{}{automata_nfa_lang}

                \code{nfa_lpath}{}{automata_nfa_lpath}

                If $\delta$ is functional, we speak of deterministic finite automata. In this case, we also assume $\delta$ to be total so that we can write it as a function. 
                This allows us to directly define the acceptance critereon. 

                \code{dfa}{Deterministic Finite Automata}{automata_dfa}
                \code{dfa_accept}{}{automata_dfa_accept}
                \code{dfa_lang}{}{automata_dfa_lang}

                \subsubsection{Equivalence}
                    \paragraph{} 
                        Deterministic and non-deterministic finite automata are both equally powerful. 
                        One direction is trivial since every DFA is also a NFA. 
                        We prove the other direction using the powerset construction. 
                        Given NFA $A$, we construct an equivalent DFA $A_{dfa}$ in the following way: 
                        we take the powerset of the given NFA's state space as our new state space. 
                        The new starting space is the singleton set containing the original starting state. 
                        A state is final if and only if it contains an original final state. 
                        Transitions are done for every original state contained in the new state, i.e. 
                        \[
                            (P, a, Q) \in \delta_{dfa} \Longleftrightarrow Q = \bigcup \limits _{p \in P} \{ q | (p,a,q) \in \delta \}.
                        \]

                    \code{powerset_state}{Powerset Construction}{automata_powerset_state}
                    \vspace{-0.4cm}
                    \code{}{}{automata_powerset_s0}
                    \vspace{-0.4cm}
                    \code{}{}{automata_nfa_to_dfa}

        \section{Connected Components}
            \paragraph{} 
            We use \ssreflect's excellent fingraph library for finite graphs in order to extract the connected component (i.e. all reachable states) from an automaton.
            From this, we construct a equivalent automaton (the connected automaton) that has only reachable states.

        \section{Emptiness}
            \paragraph{}
                Given an automaton $A$, we can now check if $\lang{A} = \emptyset$. We simply obtain the connected automaton $A_c$ of $A$ and compute $F_c \stackrel{?}{=} \emptyset$. This is correct because $F_c = \emptyset \Leftrightarrow \lang{A_c} = \emptyset$ and $\lang{A_c} = \lang{A}$.

        \section{Regular Expressions and Finite Automata}

            \paragraph{} 
                We proof that there is a finite automaton for every regular expression and vice versa. 

            \subsection{Regular Expressions to Finite Automata}

                \paragraph{} 
                    We give an equivalent automaton for every single constructor of regular expressions.
                    Out of those proofs, only .... are interesting.

            \subsection{Deciding Equivalence of Regular Expressions}

                \paragraph{} 
                    Based on our procedure to build an equivalent automaton from a regular expression, we can now decide equivalence of regular expressions. Given $r_1$ and $r_2$, we construct equivalent DFA $A_1$ and $A_2$ as above.
                    Next, we construct DFA $A$ s.t. the language of $A$ is the symmetric difference of the languages of $A_1$ and $A_2$, i.e. 
                    \[ \lang{A} = \lang{A_1} \ominus \lang{A_2} = \lang{A_1} \cap \neg \lang{A_2} \cup \lang{A_2} \cap \neg \lang{A_1}.
                    \] 
                    We then check for emptiness of $A$. The correctness of this procedure follows directly from 
                    \[ 
                        \lang{A_1} \ominus \lang{A_2} = \emptyset \Leftrightarrow \lang{A_1} = \lang{A_2}.
                    \]
                    

            \subsection{Finite Automata to Regular Expressions}
                
                \paragraph{}
                Since we are given only an automaton it is not obvious how to partition our proof obligations into smaller parts.
                We used Kleene's proof, the transitive closure method. 
                Essentially, this method provides us with an inductive structure in our proofs. Still, this is the most challenging proof in terms of infrastructure needed.

            \paragraph{} 


            

        \chapter{Myhill-Nerode Theorem}

            \section{Definition}

                \paragraph{} Given a language $L$, the Myhill-Nerode relation $\approx_L$ is defined s.t. 
                \[
                    \forall u, v \in \Sigma^*. \,
                    u \approx_L v \, \Longleftrightarrow \, 
                    \forall w \in \Sigma^*.\, u \cdot w \in L \Leftrightarrow v \cdot w \in L.
                \]

                \code{mn}{Myhill-Nerode relation}{myhill_nerode_MN}

                The Myhill-Nerode thereom states that, given a language $L$,
                \[
                    L \in REG \, \Longleftrightarrow \, \approx_L \mbox{ is of finite index.}
                \]

            \section{Finite Partitionings and Equivalence Classes}

                \paragraph{}
                    \coq does not have quotient types. 

                \paragraph{} 
                    A finite partitioning is a function from $\Sigma^*$ to some finite type $F$. 
                    We use this concept to model equivalent classes in \coq. 
                    A finite partitioning of the Myhill-Nerode relation is a finite partitioning $f$ that also respects the Myhill-Nerode relation, i.e. 
                    \[
                        \forall u, v \in \Sigma^*. \,
                        f(u) = f(v) \Leftrightarrow u \approx_L v.
                    \]
                    

                    \code{mn_rel}{Finite partitioning of the Myhill-Nerode relation}{myhill_nerode_MN_rel}

                    A more general concept is that of a refining finite partitioning of the Myhill-Nerode relation:
                    \[
                        \forall u, v \in \Sigma^*. \,
                        f(u) = f(v) \Rightarrow u \approx_L v.
                    \]

                    \code{mn_ref}{Refining finite partitioning of the Myhill-Nerode refation}{myhill_nerode_MN_ref}






        \section{Finite Automata and Myhill-Nerode}

            \paragraph{}

            \subsection{Minimizing Equivalence Classes}

                \paragraph{}
            
            \subsection{Finite Automata to Myhill-Nerode}

                \paragraph{}

            \subsection{Myhill-Nerode to Finite Automata}

                \paragraph{}


    \chapter{Conclusion}

    \chapter{References}

    \bibliography{bib}{}
    \bibliographystyle{plain}

\end{document}
