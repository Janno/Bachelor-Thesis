\documentclass[11pt,a4paper,oneside]{book}

\input{macros.tex}

\input{includes.tex}

\title{Constructive Formalization of Regular Languages}
\author{Jan-Oliver Kaiser}

\begin{document}
    \maketitle
    \tableofcontents
    
    \chapter{Introduction}

        \paragraph{} We aim to show that an extensive, yet elegant formalization of regular languages can be achieved in constructive type theory.

        \section{Recent work}
        
            \paragraph{} There have been many publications on regular languages in recent years. Many of them investigate decidability of equivalence of regular languages, though there have also been new equivalence proofs regarding different characterizations of regular languages.

    \chapter{Coq, \ssreflect}

        \paragraph{}
        We decided to employ the Small Scale Reflection Extension (\textbf{\ssreflect}) for the \textbf{\coq} proof assistant. The most important factors in this decision were \ssreflect's excellent support for finite types, list operations and graphs. \ssreflect{} also introduces many syntactic extensions that can often be used to shorten the bookkeeping overhead of proofs considerably.

    \chapter{Decidable Languages}

        \section{Regular Languages}
        
        \paragraph{} In our formalization, we consider three well-known characterizations of regular languages: \textbf{Regular expressions} (due to Stephen Cole Kleene \cite{KleeneNets}), \textbf{finite automata}, and the characterization derived from the \textbf{Myhill-Nerode theorem} (John Myhill, Anil Nerode \cite{Nerode1958}) 
    
        \section{Regular Expressions}

            \subsection{Definition}

                \paragraph{} Regular expressions are finite expressions over an alphabet consisting of atomic expressions or subexpressions combined by operators. Every regular expressions has an associated language, either directly or by some combination of the subexpressions' languages.

                \paragraph{} Regular expressions are an inductive data structure and therefore best implemented as an inductive definition in \coq. We take the implementation from Coquand and Siles's development (\cite{DBLP:conf/cpp/CoquandS11}), which is also based on \ssreflect and comes with a lot of useful infrastructure for our proofs.

                \subsubsection{Computing Language Membership}

                    \paragraph{}

            

    \chapter{Finite Automata}
        \section{Definition}

            \paragraph{}

            \subsection{Determinism and Non-Determinism}

                \paragraph{}

            \subsection{Totality}

                \paragraph{}

        \section{Regular Expressions and Finite Automata}

            \paragraph{} We proof that there is a finite automaton for every regular expression and vice versa.  

            \subsection{Regular Expressions to Finite Automata}

                \paragraph{}

            \subsection{Deciding Equivalence of Regular Expressions}

                \paragraph{}

            \subsection{Finite Automata to Regular Expressions}

                \paragraph{}

            \paragraph{} 


            

        \chapter{Myhill-Nerode Theorem}

            \section{Myhill-Nerode Relation}

                \paragraph{}
        
            \section{Statement of the Theorem}

                \paragraph{}

            \section{Equivalence Classes and Finite Partitionings}

                \paragraph{}





        \section{Finite Automata and Myhill-Nerode}

            \paragraph{}

            \subsection{Minimizing Equivalence Classes}

                \paragraph{}
            
            \subsection{Finite Automata to Myhill-Nerode}

                \paragraph{}

            \subsection{Myhill-Nerode to Finite Automata}

                \paragraph{}


    \chapter{Conclusion}

    \chapter{References}

    \bibliography{bib}{}
    \bibliographystyle{plain}

\end{document}
