
\chapter{Finite Automata}
\label{chap:FA}

Another way of characterizing regular languages are finite automata (FA)\cite{DBLP:books/daglib/0011126}. 
We will show that the languages of finite automata are exactly the regular languages. 
Furthermore, we will also derive a decision procedure for equivalence of regular expressions.

\section{Definition}
A finite automaton consists of
\begin{enumerate}
    \item
        finite set of states $Q$, 
    \item 
        a starting state $s \in Q$, 
    \item 
        a set of final states $F \subseteq Q$ 
    \item 
        and a state-transition relation $\delta$. 
\end{enumerate}

We define a \textbf{run} of a word $w \in \Sigma^*$ on an automaton $A = (Q, s, F, \delta)$ as any sequence of states $\sigma$ such that 
$\forall \, 0 <= i < \vert\sigma\vert-2. \, (\sigma_i, w_i, \sigma_{i-1}) \in \delta$.
A word $w$ is \textbf{accepted} by $A$ in state $x$ if and only if there exists a run $\sigma$ of $w$ on $A$ such that $\sigma_0 = x \, \wedge \, \sigma_{\vert\sigma\vert-1} \in F$.
The resulting set of accepted words is denoted by $\acc{x}{A}$.
The \textbf{language} of $A$ is exactly $\acc{s}{A}$ and is denoted $\lang{A}$. 

\subsection{Non-Deterministic Finite Automata}
Finite automata can be \textbf{non-deterministic} (NFA) in the sense that there exist multiple distinct runs for a word. 
This is the case if and only if $\delta$ is not functional.

\code{nfa}{Non-Deterministic Finite Automata}{automata_nfa}
\codeblock{nfa_accept}{}{automata_nfa_accept}
\codeblock{nfa_lang}{}{automata_nfa_lang}

\paragraph{}
The acceptance criterion given here avoids the matter of runs.
In many cases, this will help us with proofs by in induction on the accepted word.
However, we will need runs in some of the proofs.
Due to the fact that runs are not unique on NFAs, 
we give a predicate that decides if a run on $A$ is valid for a word $w$.
We then show that the acceptance criterion given above corresponds to the mathematical definition in terms of runs.

\code{nfa_run}{}{automata_nfa_run}
\codeblock{nfa_run_accept}{}{automata_nfa_run_accept_head}

\subsection{Deterministic Finite Automata}
For functional $\delta$, we speak of \textbf{deterministic} finite automata (DFA). 
In this case, we write $\delta$ as a function in our \coq\ development. 
%This allows us to define the acceptance criterion in terms of the unique sequence of transitions on the automaton. 

\code{dfa}{Deterministic Finite Automata}{automata_dfa}
\codeblock{dfa_accept'}{}{automata_dfa_accept}
\codeblock{dfa_lang}{}{automata_dfa_lang}

\paragraph{}
Again, we avoid runs in our formalization of the acceptance criterion in favor of a acceptance criterion that is easier to work with in proofs.
In this case, however, we can give a function that computes the unique run of a word on $A$.
This allows us to give an alternative acceptance criterion that is closer to the mathematical definition.
We also prove that both criteria are equivalent.

\code{dfa_run'}{}{automata_dfa_run'}
\codeblock{dfa_run_accept}{}{automata_dfa_run_accept_head}


%\paragraph{}
%We can give simpler formalizations of the acceptance on deterministic and non-deterministic automata.
%These will allow us to hide runs and runs as much as possible and instead work with a simple, inductive, boolean predicate.

%\code{automata_dfa_accept}{}{automata_dfa_accept}

\subsubsection{Equivalence of Automata}
\begin{definition}
    We say that two automata are \textbf{equivalent} if and only if their languages are equal.
\end{definition}

\subsubsection{Equivalence between DFA and NFA}
\paragraph{} 
Deterministic and non-deterministic finite automata are equally expressive. 
One direction is trivial since every DFA can be seen as a NFA. 
We prove the other direction using the powerset construction. 
Given NFA $A$, we construct an equivalent DFA $A_{det}$ in the following way:
%The new set of states is the powerset of the given NFA's set of states. 
%The new starting state is the singleton set containing the original starting state. 
%A state is final if and only if it contains an original final state. 
%The transition function on powerset states is defined as follows:

\begin{eqnarray*}
    Q_{det} & := & 2^Q \\ %\{P \; | \; P \subseteq Q\} \\
    {s}_{det} & := & \{ s \} \\
    F_{det} & := & \{ P \; | \; P \in Q_{det} \wedge P \cap F \neq \emptyset \} \\
    \delta_{det} & := & \{ (P,a,\bigcup \limits _{p \in P} \{ q \; | \; q \in Q, (p,a,q) \in \delta \}) \; | \; P \in Q_{det}, a \in \Sigma \}.     \\
    A_{det} &:=&  (Q_{det}, s_{det}, F_{det}, \delta_{det}).
\end{eqnarray*}

\paragraph{}
The formalization of $A_{det}$ is straight-forward. 
We leave the set of states \lstinline!{set A}! implicit.

\code{}{}{automata_nfa_to_dfa}

\begin{lemma}
    \label{nfa_to_dfa_complete}
    For all powerset states $X$ and for all states $x$ with $x \in X$ we have that
    \begin{equation*}
        \acc{x}{A} \subseteq \acc{X}{A_{det}}.
    \end{equation*}
\end{lemma}

\begin{proof}
    Let $w \in \acc{x}{A}$. We proof by induction on $w$ that $w \in \acc{X}{A_{det}}$. 
    \begin{itemize}
        \item
            For $w = \varepsilon$ and $\varepsilon \in \acc{x}{A}$ we get $x \in F$ from $\varepsilon \in \acc{x}{A}$. 
            From $x \in X$ we get $X \cap F \neq \emptyset$ and therefore $\varepsilon \in \acc{X}{A_{det}}$.
        \item
            For $w = a w'$ and $a w' \in \acc{x}{A}$ we get $y$ such that $w' \in \acc{y}{A}$ and $(x,a,y) \in \delta$.
            The latter gives us $y \in Y$ where $Y$ is such that $(X, a, Y) \in \delta_{det}$.
            With $y \in Y$ and $w' \in \acc{y}{A}$ we get 
            which gives us $w' \in \acc{Y}{A_{det}}$ by induction hypothesis.
            With $(X, a, Y) \in \delta_{det}$ we get $a w' \in \acc{X}{A_{det}}$.
    \end{itemize}
\end{proof}


\begin{lemma}
    \label{nfa_to_dfa_sound}
    For all powerset states $X$ and all words $w \in \acc{X}{A_{det}}$ there exists a state $x$ such that 
    \begin{equation*}
        x \in X \wedge
        w \in \acc{x}{A}.
    \end{equation*}
\end{lemma}

\begin{proof}
    We do an induction on $w \in \Sigma^*$. %that there exists $x$ such that $x \in X \wedge w \in \acc{x}{A}$. 
    \begin{itemize}
        \item
            For $w = \varepsilon$ and $\varepsilon \in \acc{X}{A_{det}}$ we get  $X \cap F \neq \emptyset$.
            Therefore, there exists $x$ such that $x \in X$ and $x \in F$.
            Thus, we have $\varepsilon \in \acc{x}{A}$.
        \item
            For $w = a w'$ and $a w' \in \acc{X}{A_{det}}$ we get $Y$ such that $w' \in \acc{Y}{A_{det}}$ and $(X,a,Y) \in \delta_{det}$.
            From the induction hypothesis we get $y$ such that $y \in Y$ and $w' \in \acc{y}{A}$.
            From $y \in Y$ and $(X, a, Y) \in \delta_{det}$ we get $x$ such that $x \in X$ and $(x, a, y) \in \delta$.
            Thus, $a w' \in \acc{x}{A}$.
    \end{itemize}
\end{proof}

\begin{theorem}
    The powerset automaton $A_{det}$ accepts the same language as $A$, i.e.
    \begin{equation*}        
        \lang{A} = \lang{A_{det}}.        
    \end{equation*}
\end{theorem}
\begin{proof}
    ``$\subseteq$'' 
    This follows directly from lemma \ref{nfa_to_dfa_complete} with $x = s$ and $X = {s}_{det}$.

    ``$\supseteq$''
    From lemma \ref{nfa_to_dfa_sound} with $X = {s}_{det}$ we get 
    $\acc{s_{det}}{A_{det}} \subseteq \acc{s}{A}$, which proves the claim.
\end{proof}

\paragraph{}
The formalization of this proof is straight-forward and follows the plan laid out above. 
The corresponding Lemmas are:
\code{powerset_complete}{}{automata_nfa_to_dfa_complete_head}
\codeblock{powerset_sound}{}{automata_nfa_to_dfa_sound_head}
\codeblock{powerset_correct}{}{automata_nfa_to_dfa_correct_head}


\section{Connected Components}
\paragraph{} 
Finite automata can have isolated subsets of states that are not reachable from the starting state. 
These states can not contribute to the language of the automaton since there are no runs from the starting state to any of those unreachable states.
It will later be useful to have automata that only contain reachable states. 
Therefore, we define a procedure to extract the connected component containing the starting state from a given automaton.

\begin{definition}
    Let $A = (Q, s, F, \delta)$ be a DFA.
    We define $\mathrm{reachable1}$ such that for all x and y, 
    $(x,y) \in \mathrm{reachable1} \iff \exists a, (x,a,y) \in \delta$.
    We define $\mathrm{reachable} := \{y \; | \; (s,y) \in \mathrm{reachable1}^*\}$, 
    where $\mathrm{reachable1}^*$ denotes the transitive closure of $\mathrm{reachable1}$.
    With this, we can define the connected automaton $A_c$:
    \begin{eqnarray*}
        Q_c & := & Q \cap reachable \\
        s_c & := & s \\
        F_c & := & F \cap reachable \\
        \delta_c & := & \{(x, a, y) \; | \; (x, a, y) \in \delta \wedge x,y \in Q_c \} \\
        A_c &:=& (Q_c, s_c, F_c, \delta_c).
    \end{eqnarray*}
\end{definition}

\paragraph{}
We make use of \ssreflect's $connect$ predicate to extract a sequence of all states reachable from $s$. 
From this, we construct a finite type and use that as the new set of states. 
These new states carry a proof of reachability. %(\lstinline{ssvalP}).
We also have to give a transition function that ensures transitions always end in reachable states.

\code{automata_reachable1}{}{automata_reachable1}
\codeblock{automata_reachable}{}{automata_reachable}
\codeblock{automata_reachable0}{}{automata_reachable0_head}
\codeblock{automata_reachable_step}{}{automata_reachable_step_head}
\codeblock{automata_dfa_connected}{}{automata_dfa_connected}

\todo{Make this understandable}

\begin{lemma}
    \label{dfa_connected_correct'}
    For every state $x \in \mathrm{reachable}$ we have that
    \begin{equation*}
        \acc{x}{A_c} = \acc{x}{A}.
    \end{equation*}
\end{lemma}
\begin{proof}
    ``$\subseteq$'' Trivial.
    ``$\supseteq$''
    We do an induction on $w$.
    \begin{itemize}
        \item
            For $w = \varepsilon$ we have $\varepsilon \in \acc{x}{A}$ and therefore $x \in F$. 
            With $x \in reachable$ we get $x \in F_c$. 
            Thus, $\varepsilon \in \acc{x}{A_c}$.
        \item
            For $w = a w'$ we have have $y \in Q$ such that $(x, a, y) \in \delta$ and $w' \in \acc{y}{A}$.
            From $x \in \mathrm{reachable}$ we get $y \in \mathrm{reachable}$ by transitivity.
            Therefore, $(x,a,y) \in \delta_c$.
            The induction hypothesis gives us $w' \in \acc{y}{A_c}$. 
            Thus, $a w' \in \acc{x}{A_c}$.
    \end{itemize}
\end{proof}

\begin{theorem}
    \label{dfa_connected_correct}
    The language of the connected automaton $A_c$ is identical to that of the original automaton $A$, i.e.
    \begin{equation*}
        \lang{A} = \lang{A_c}.        
    \end{equation*}
\end{theorem}

\begin{proof}
    By reflexivity, we have $s \in \mathrm{reachable}$. 
    We use lemma \ref{dfa_connected_correct'} with $x = s$ to prove the claim.
        %Unreachable states have no influence on the language of an automaton because there is no run from the starting state that contains such a state.
\end{proof}

\paragraph{}
The formalization of lemma \ref{dfa_connected_correct'} and theorem \ref{dfa_connected_correct} is straight-forward.

\code{automata_dfa_connected_correct'}{}{automata_dfa_connected_correct'_head}
\codeblock{automata_dfa_connected_correct}{}{automata_dfa_connected_correct_head}

\paragraph{}
To make use of the fact that $A_c$ is fully connected, we will proof a characteristic property of $A_c$. 

\begin{definition}
    A \textbf{representative} of a state $x$ is a word $w$ such that the unique run of $w$ on $A_c$ ends in $x$.
\end{definition}

\begin{lemma}
    \label{dfa_connected_repr}
    We can give a representative for every state $x \in Q_c$.
    %\todo{Sigma?}
\end{lemma}

\begin{proof}
    $x$ carries a proof of reachability.
    From this, we get a path through the graph of $\mathrm{reachable1}$ that ends ind $x$.
    We build the representative by extracting the edges of the path and building a word from those.
    \todo{Choice?}
\end{proof}

\paragraph{}
The formalization of theorem \ref{dfa_connected_repr} includes a more general version of the theorem, 
which facilitates the proof by induction over the path.

\code{dfa_connected_repr'}{}{automata_dfa_connected_repr'_head}
\codeblock{}{}{automata_dfa_connected_repr_head}


\section{Emptiness}
\paragraph{}
Given an automaton $A$, we can check if $\lang{A} = \emptyset$. We simply obtain the connected automaton of $A$ and check if there are any final states left. 

\begin{theorem}
    \label{dfa_lang_empty}
    The language of the connected automaton $A_c$ is empty if and only if its set of final states $F_c$ is empty, i.e.
    \begin{equation*}
        \lang{A} = \emptyset \iff F_c = \emptyset.
    \end{equation*}
\end{theorem}

\begin{proof}
    By theorem \ref{dfa_connected_correct} we have $\lang{A} = \lang{A_c}$.
    Therefore, it suffices to show
    \begin{equation*}
        \lang{A_c} = \emptyset \iff F_c = \emptyset.
    \end{equation*}
    ``$\Leftarrow$''
    We have $\lang{A_c} = \emptyset$ and have to show that for all $x \in Q_c$, $x \notin F_c$.
    Let $x \in Q_c$. 
    By lemma \ref{dfa_connected_repr} we get $w$ such that the unique run of $w$ on $A_c$
    ends in $x$. 
    We use $\lang{A_c} = \emptyset$ to get $w \notin \lang{A_c}$, 
    which implies that the run of $w$ on $A_c$ ends in a non-final state.
    By substituting the last state of the run by $x$ we get $x \notin F_c$.
    ``$\Rightarrow$''
    We have $F_c = \emptyset$ and have to show that for all words $w$, $w \notin \lang{A_c}$.
    We use $F_c = \emptyset$ to show that the last state of the run of $w$ on $A_c$ is non-final.
    Thus, $w \notin \lang{A_c}$.

    Thus, emptiness is decidable.
\end{proof}


\paragraph{}
The formalization of lemma \ref{dfa_lang_empty} is split in two parts to facilitate its application. 

\code{}{}{automata_dfa_lang_empty}
\codeblock{dfa_lang_empty_complete}{}{automata_dfa_lang_empty_complete_head}
\codeblock{dfa_lang_empty_sound}{}{automata_dfa_lang_empty_sound_head}
\codeblock{dfa_lang_empty_correct}{}{automata_dfa_lang_empty_correct_head}



\section{Deciding Equivalence of Finite Automata}
Given finite automata $A_1$ and $A_2$, we construct DFA $A$ such that the language of $A$ is the symmetric difference of the languages of $A_1$ and $A_2$, i.e.,
\begin{equation*}          
    \lang{A} := \lang{A_1} \ominus \lang{A_2} = \lang{A_1} \cap \neg \lang{A_2} \cup \lang{A_2} \cap \neg \lang{A_1}.      
\end{equation*}
\begin{theorem} The equivalence of $A_1$ and $A_2$ is decidable, i.e.
    \label{dfa_sym_diff_correct}
    \begin{equation*}                
        \lang{A_1} = \lang{A_2} \mbox{ if and only if } \lang{A} \mbox{ is empty. }                
    \end{equation*}
\end{theorem}
\begin{proof}
    The correctness of this procedure follows from the properties of the symmetric difference operator, i.e.
    \begin{equation*}                  
        \lang{A_1} \ominus \lang{A_2} = \emptyset \Leftrightarrow \lang{A_1} = \lang{A_2}.                  
    \end{equation*}
    Thus, equivalence is decidable.    
\end{proof}

\code{}{Formalization of theorem \ref{dfa_sym_diff_correct}}{automata_dfa_sym_diff}
\codeblock{}{}{automata_dfa_sym_diff_correct_head}

\section{Regular Expressions and Finite Automata}

\paragraph{} 
We prove that there is a finite automaton for every extended regular expression and vice versa. 
In fact, we can give a standard regular expression for every finite automaton.
With this, we will prove that extended regular expressions are equivalent to standard regular expressions, 
thereby proving closure under intersection and negation.


\subsection{Regular Expressions to Finite Automata}

\paragraph{} 
We prove that there exists an equivalent automaton for every extended regular expression.
The structure of this proof is given by the inductive nature of regular expressions.
For every constructor, we provide an equivalent automaton.

\paragraph{}
Depending on the constructor of the regular expression, we will construct an equivalent DFA or NFA.
\lstinline{Void}, \lstinline{Eps}, \lstinline{Dot}, \lstinline{Atom}, \lstinline{Plus}, \lstinline{And} and \lstinline{Not} are very easy to implement on DFAs, whereas \lstinline{Star} and \lstinline{Conc} lend themselves well to NFAs.

\subsubsection{Void}
\begin{definition}
    We define an empty DFA with a single, non-accepting state, i.e.
    \begin{equation*}
        A_\emptyset := (\{t\}, t, \emptyset, \{(t, a, t) \; | \; a \in \Sigma\}).
    \end{equation*}
\end{definition}

\begin{lemma}
    \label{dfa_empty_correct}
    The language of the empty DFA is empty, i.e.
    \begin{equation*}
        \lang{E} = \emptyset.
    \end{equation*}
\end{lemma}

\begin{proof}
    $A_\emptyset$ has no final states, i.e. no run can end in a final state.
\end{proof}


\code{}{}{automata_dfa_void}
\codeblock{}{}{automata_dfa_void_correct_head}


\subsubsection{Eps}
\begin{definition}
    We define an automaton that accepts only the empty word, i.e.
    \begin{equation*}
        A_\varepsilon := (\{t, f\}, t, \{f\}, \{(x, a, f) \; | \; x \in \{t, f\}, a \in \Sigma\}).
    \end{equation*}
\end{definition}

\begin{lemma}
    \label{dfa_eps_correct'}
    $A_\varepsilon$ accepts no word in state $f$, i.e. for all w,
    \begin{equation*}
        w \notin \acc{f}{A_\varepsilon}.
    \end{equation*}
\end{lemma}
\begin{proof}
    Let $w \in \Sigma^*$.
    We do an induction on $w$. 
    For $w = \varepsilon$ we get $\varepsilon \notin \acc{f}{A_\varepsilon}$ by $f \notin F_\varepsilon$. 
    For $w = aw'$ we have $w' \notin \acc{f}{A_\varepsilon}$. 
    Furthermore, $(f, a, f) \in \delta_\varepsilon$.
    Therefore, $aw' \notin \acc{f}{A_\varepsilon}$.
\end{proof}

\begin{lemma}
    \label{dfa_eps_correct}
    The language of $A_\varepsilon$ is exactly the singleton set containing the empty word, i.e.
    \begin{equation*}
        \lang{A_\varepsilon} = \{\varepsilon\}.
    \end{equation*}
\end{lemma}

\begin{proof}
    Let $w \in \Sigma^*$.
    We do an induction on $w$. 
    For $w = \varepsilon$ we have $\varepsilon \in \lang{A_\varepsilon}$ and $\varepsilon \in \{\varepsilon\}$.
    Therefore, both directions are trivial.
    For $w = aw'$ we consider both directions independently. \\
    ``$\Rightarrow$'' We have $(t, a, f) \in \delta_\varepsilon$ and $w' \in \acc{f}{A_\varepsilon}$. By lemma \ref{dfa_eps_correct'}, this is a contradiction. \\
    ``$\Leftarrow$'' We get a straigt-forward contradiction from $aw' \in \{\varepsilon\}$.
\end{proof}

\code{}{}{automata_dfa_eps}
\codeblock{}{}{automata_dfa_eps_correct_head}
\todo{reflect?}


\subsubsection{Dot}
\begin{definition}
    We define an automaton that accepts the set of all singleton words, i.e.
    \begin{equation*}
        A_{Dot} := (\{s, t, f\}, s, \{t\}, 
        \{(s, a, t) \; | \; a \in \Sigma\}
        \; \cup \;
        \{(x, a, f) \; | \; x \in \{t, f\}, a \in \Sigma\}
        ).
    \end{equation*}
\end{definition}

\begin{lemma}
    \label{dfa_dot_correct''}
    $A_{Dot}$ does not accept any word in state $f$, i.e. $\acc{f}{A_{Dot}} = \emptyset$.
\end{lemma}
\begin{proof}
    We prove this by induction on $w \in \Sigma^*$. 
    For $w = \varepsilon$ we have $\varepsilon \notin \acc{f}{A_{Dot}}$ by $f \notin F_{Dot}$.
    For $w = aw'$ we have $(f, a, f) \in \delta_{Dot}$ and $w' \notin \acc{f}{A_{Dot}}$ by induction hypothesis.
    Thus, $aw' \notin \acc{f}{A_{Dot}}$.
\end{proof}

\begin{lemma}
    \label{dfa_dot_correct'}
    $A_{Dot}$ accepts exactly the empty word in state $t$, i.e. $\acc{t}{A_{Dot}} = \{\varepsilon\}$.
\end{lemma}
\begin{proof}
    Let $w \in \Sigma^*$. 
    We do a case distinction on $w$.
    For $w = \varepsilon$ we have $\varepsilon in \acc{t}{A_{Dot}}$ by $t \in F_{Dot}$. We also have $\varepsilon \in \{\varepsilon\}$.
    For $w = aw'$ we get $(t, a, f) \in \delta_{Dot}$. 
    Since $aw' \notin \{\varepsilon\}$ it suffices to show that 
    $w' \notin \acc{f}{A_{Dot}}$,
    which we have by lemma \ref{dfa_dot_correct''}.
\end{proof}

\code{}{}{automata_dfa_dot}
\codeblock{}{}{automata_dfa_dot_correct''_head}
\codeblock{}{}{automata_dfa_dot_correct'_head}
\codeblock{}{}{automata_dfa_dot_correct_head}
\todo{reflect?}

\subsubsection{Not}
\begin{definition}
    Given DFA $A=(Q,s,F,\delta)$, the complement automaton $A_\neg$ is constructed by switching accepting and non-accepting states, i.e.
    \begin{equation*}
       A_\neg := (Q,s,Q\backslash F,\delta). 
    \end{equation*}
\end{definition}

\begin{lemma}
    \label{dfa_compl_correct'}
    For every state $x \in Q$, we have that $w \in \Sigma^*$ is accepted in $x$ by $A_\neg$ if and only if it is not accepted in $x$ by $A$, i.e. $\acc{x}{A_\neg} = \Sigma^* \backslash \acc{x}{A}$ 
\end{lemma}
\begin{proof}
    We do an induction on $w$.
    For $w = \varepsilon$ we have $\varepsilon \in \acc{x}{A_\neg} \iff \varepsilon \in \acc{x}{A}$ from
    $x \in F \iff x \notin Q\backslash F$.
    For $w = aw'$ we get $(y,a,x) \in \delta$. 
    By induction hypothesis, $w' \in \acc{x}{A_\neg} \iff w' \notin \acc{x}{A}$
    Thus, $aw' \in \acc{y}{A_\neg} \iff aw' \notin \acc{y}{A}$.
\end{proof}
\begin{lemma}
    $A_\neg$ accepts the complement language of $A$, i.e. $\lang{A_\neg} = \Sigma^* \backslash \lang{A}$.
    \label{dfa_compl_correct}
\end{lemma}
\begin{proof}
    This follows directly from lemma \ref{dfa_compl_correct'} with $x = s$.
\end{proof}

\subsubsection{Plus}
\begin{definition}
    Given DFAs $A_1=(Q_1, s_1, F_1, \delta_1)$ and $A_2=(Q_2, s_2, F_2, \delta_2)$ we construct the disjunction automaton  in the following way:
    \begin{eqnarray*}
        Q_\vee &:=& Q_1 \times Q_2 \\
        s_\vee &:=& (s_1, s_2) \\
        F_\vee &:=& \{(x_1,x_2) \; | \; x_1 \in F_1 \vee x_2 \in F_2\} \\
        \delta_\vee &:=& \{( (x_1, x_2),a,(y_1, y_2)) \; | \; a \in \Sigma, (x_1, a, y_1) \in \delta_1, (x_2, a, y_2) \in \delta_2 \} \\
        A_\vee &:=& (Q_\vee, s_\vee, F_\vee, \delta_\vee).
    \end{eqnarray*}
\end{definition}

\begin{lemma}
    \label{dfa_disj_correct'}
    For every state $(x_1, x_2) \in Q_\vee$, we have that
    \begin{equation*}
        \acc{(x_1, x_2)}{A_\vee} = \acc{x_1}{A_1} \cup \acc{x_2}{A_2}.
    \end{equation*}
\end{lemma}
\begin{proof}
    We do a proof by induction on $w \in \Sigma^*$.
    For $w = \varepsilon$ we have, by definition of $F_\vee$, 
    $%\begin{equation*}
    \varepsilon \in \acc{(x_1, x_2)}{A_\vee} 
    \iff \varepsilon \in \acc{x_1}{A_1} \vee \varepsilon \in \acc{x_2}{A_2}.
    $%\end{equation*} 
    \\
    For $w = aw'$ we get $(x_1, a, y_1) \in \delta_1$ and $(x_2, a, y_2) \in \delta_2$.
    By induction hypothesis, we also have $w' \in \acc{x_1}{A_1} \vee w' \in \acc{x_2}{A_2}$.
    Thus, we get $aw' \in \acc{y_1}{A_1} \vee aw' \in \acc{x_2}{A_2}$.
\end{proof}

\begin{lemma}
    $\lang{A_\vee} = \lang{A_1} \cup \lang{A_2}$.
    \label{dfa_disj_correct}
\end{lemma}
\begin{proof}
    This follows directly from lemma \ref{dfa_disj_correct'} with $x = (s_1, s_2)$.
\end{proof}


\code{}{}{automata_dfa_disj}
\codeblock{}{}{automata_dfa_disj_correct'_head}
\codeblock{}{}{automata_dfa_disj_correct_head}


\subsubsection{And}
\begin{definition}
    Given DFAs 
    $A_1=(Q_1, s_1, F_1, \delta_1)$ and $A_2=(Q_2, s_2, F_2, \delta_2)$ 
    we construct the conjunction automaton  in the following way:
    \begin{eqnarray*}
        Q_\wedge &:=& Q_1 \times Q_2 \\
        s_\wedge &:=& (s_1, s_2) \\
        F_\wedge &:=& \{(x_1,x_2) \; | \; x_1 \in F_1 \wedge x_2 \in F_2\} \\
        \delta_\wedge &:=& \{( (x_1, x_2),a,(y_1, y_2)) \; | \; a \in \Sigma, (x_1, a, y_1) \in \delta_1, (x_2, a, y_2) \in \delta_2 \} \\
        A_\wedge &:=& (Q_\wedge, s_\wedge, F_\wedge, \delta_\wedge).
    \end{eqnarray*}
\end{definition}

\begin{lemma}
    \label{dfa_conj_correct'}
    For every state $(x_1, x_2) \in Q_\wedge$, we have that
    \begin{equation*}
        \acc{(x_1, x_2)}{A_\wedge} = \acc{x_1}{A_1} \cup \acc{x_2}{A_2}.
    \end{equation*}
\end{lemma}
\begin{proof}
    This proof is very similar to lemma \ref{dfa_disj_correct'}.
    We do a proof by induction on $w \in \Sigma^*$.
    For $w = \varepsilon$ we have, by definition of $F_\wedge$, 
    $%\begin{equation*}
    \varepsilon \in \acc{(x_1, x_2)}{A_\wedge} 
    \iff \varepsilon \in \acc{x_1}{A_1} \wedge \varepsilon \in \acc{x_2}{A_2}.
    $%\end{equation*} 
    \\
    For $w = aw'$ we get $(x_1, a, y_1) \in \delta_1$ and $(x_2, a, y_2) \in \delta_2$.
    By induction hypothesis, we also have $w' \in \acc{x_1}{A_1} \wedge w' \in \acc{x_2}{A_2}$.
    Thus, we get $aw' \in \acc{y_1}{A_1} \wedge aw' \in \acc{x_2}{A_2}$.
\end{proof}

\begin{lemma}
    $\lang{A_\wedge} = \lang{A_1} \cap \lang{A_2}$.
    \label{dfa_conj_correct}
\end{lemma}
\begin{proof}
    This follows directly from lemma \ref{dfa_conj_correct'} with $x = (s_1, s_2)$.
\end{proof}


\code{}{}{automata_dfa_conj}
\codeblock{}{}{automata_dfa_conj_correct'_head}
\codeblock{}{}{automata_dfa_conj_correct_head}


\subsubsection{Conc}
\begin{definition}
   Given two NFAs
    $A_1=(Q_1, s_1, F_1, \delta_1)$ and $A_2=(Q_2, s_2, F_2, \delta_2)$ 
    we construct the concatenation automaton in the following way:
    \begin{eqnarray*}
        Q_{Conc} &:=& Q_1 \; \dotcup \; Q_2 \\
        s_{Conc} &:=& s_1 \\
        F_{Conc} &:=&  \mathbf{TODO}\\
        \delta_{Conc} &:=& \delta_1 \; \cup \; \delta_2 \; \cup \; 
                         \{(x, a, y) \; | \; x \in Q_1, y \in Q_2, (s_2, a, y) \in \delta_2 \} \\
        %\{( (x_1, x_2),a,(y_1, y_2)) \; | \; a \in \Sigma, (x_1, a, y_1) \in \delta_1, (x_2, a, y_2) \in \delta_2 \} \\
        A_{Conc} &:=& (Q_{Conc}, s_{Conc}, F_{Conc}, \delta_{Conc}).
    \end{eqnarray*}\todo{Case dist. on $s_2 \in F_2$}
\end{definition}

\begin{lemma}
    \label{dfa_conc_cont}
    Every run of $A_2$ can be mapped to a run in $A_3$.
\end{lemma}
\begin{proof}
    Let $\sigma$ be a run starting in $x$ for $w \in \Sigma^*$ on $A_2$.
    We do an induction on $\sigma$.
    For $|\sigma| = 0$\todo{symbol for empty run}%
    we have $w = \varepsilon$.
    Therefore, we have that $\sigma$ is also a run starting in $x$ for $\varepsilon$ on $A_{Conc}$
    For $\sigma = y\sigma'$ we have $w = aw'$, $(x, a, y) \in \delta_2$.
    By definition of $\delta_{Conc}$ we also have $(x, a, y) \in \delta_{Conc}$.
    By induction hypothesis, we have that $\sigma'$ is a run for $w'$ starting in $y$ on $A_{Conc}$.
    Thus, $y\sigma'$ is a run for $aw'$ starting in $x$ on $A_{Conc}$.
\end{proof}

\todo{Include all proofs}

\subsection{Deciding Equivalence of Regular Expressions}

\paragraph{} 
Based on our procedure to construct an equivalent automaton from a regular expression, we can decide equivalence of regular expressions. Given $r_1$ and $r_2$, we construct equivalent DFA $A_1$ and $A_2$ as above.


\subsection{Finite Automata to Regular Expressions}
\paragraph{}
We prove that there is an equivalent standard regular expression for every finite automaton.


\paragraph{}
Since we are given an automaton it is not obvious how to partition our proof obligations into smaller parts.
We use Kleene's original proof, the transitive closure method. 
This method recursively constructs a regular expression that is equivalent to the given automaton.
Given a DFA $A$, we first assign some ordering to its states. We then define $R^k_{i,j}$ such that 
$\lang{R^k_{i,j}}$ is the set of all words that have a run on $A$ starting in state $i$ that ends in state $j$ without ever leaving a state smaller than $k$. 
The base case $R^{0}_{i,j}$ is the set of all singleton words that are edges between state $i$ and $j$, and $\varepsilon$ if $i=j$. 
Given $R^k_{i,j}$ we can easily define $R^{k+1}_{i,j}$ based on the observation that only one new state has to be considered:
\todo{Insert complete formal definition}
\begin{equation*}                    
    R^{k+1}_{i,j} = R^{k}_{i,k} \cdot (R^{k}_{k,k})^* \cdot R^{k}_{k,j} + R^{k}_{i,j}.                    
\end{equation*}
\paragraph{}
We make use of \ssreflect's ordinals to get an ordering on states. 
We chose to employ ordinals for $i$ and $j$, but not for $k$. 
This simplifies the inductive definitions on $k$. 
It does, however, lead to explicit conversions when $k$ is used in place of $i$ or $j$.
In fact, $i$ and $j$ are states in our \coq\ implementation. 
We only rely on ordinals for comparison to $k$.
\todo{Add implementation of $R$}
\paragraph{}
Furthermore, we define $L^k_{i,j} \subseteq \lang{A}$ in terms of runs on the automaton. 
The relation of $L^k_{i,j}$ to $\lang{A}$ can be proven very easily.
We will also prove it equivalent to $R^k_{i,j}$.
This allows us to connect $R^k_{i,j}$ to $\lang{A}$.
\code{tc_allbutlast}{}{transitive_closure_allbutlast}
\vspace{-0.3cm} 
\code{tc_L}{}{transitive_closure_L}

\begin{theorem} We can express $\lang{A}$ in terms of $L$. $L$ is equivalent to $R$.
    \label{LR}
    \begin{equation*}                          
        \lang{A} = \bigcup\limits_{f \in F} L^{|Q|}_{s, f} = \lang{\sum\limits_{f \in F} R^{|Q|}_{s, f}}.                            
    \end{equation*}
\end{theorem}

\begin{proof}
    By definition, every $w \in \lang{A}$ has a run that ends in some $f \in F$. 
    Then, by definition, $w \in  L^{|Q|}_{s, f}$. 

    \paragraph{}
    It remains to show that $\lang{R^k_{i,j}} = L^k_{i.j}$. 
    This claim can be proven by induction over $k$. 
    We begin with the inclusion of $\lang{R^k_{i,j}}$ in $L^k_{i,j}$. 
    For $k=0$, we do a case distinction on $i==j$ and unfold $R$. 
    The resulting three cases ($i==j \wedge w=\varepsilon$, $i==j \wedge |w|=1$, $i<>j \wedge |w|=1$) are easily closed. 

    The inductive step has two cases: A triple concatenation and a simple recursion. 
    The second case is solved by the inductive hypothesis.
    In the firs case, we split up the concatenation such that
    \begin{equation*}
        w = w_1 \cdot w_2 \cdot w_3 
        \wedge w_1 \in \lang{R^k_{i,k}} 
        \wedge w_2 \in \lang{(R^k_{k,k})^*} 
        \wedge w_3 \in \lang{R^k_{k,j}}.                               
    \end{equation*}
    \paragraph{}
    The induction hypothesis is applied to $w_1$ and $w_3$ to get $w_1 \in L^k_{i,k}$ and $w_3 \in L^k_{k,j}$.
    We use a lemma by Coquand and Siles that splits $w_2$ into a sequence of words from $\lang{R^k_{k,k}}$ to which we can apply the induction hypothesis. 
    Two concatenation lemmas for $L$ are used to merge the sequence of words proven to be in $L^k_{k,k}$,
    $w_1$ and $w_3$. This shows $\lang{R^k_{i,j}} \subseteq L^k_{i,j}$.

    \paragraph{}
    Next, we show the inclusion of $L^k_{i,j}$ in $\lang{R^k_{i,j}}$, again by induction over k. 
    The base case is solved by case distinction on $i==j$. 
    The inductive step requires a \textbf{splitting lemma} for $L$ which shows that every non-empty word in $L^{k+1}_{i,j}$ is either in $L^k_{i,j}$ or has a non-empty prefix in $L^k_{i,k}$ and a corresponding suffix in $L^{k+1}_{k,j}$.
    The 
    In the first case, we can apply the induction hypothesis. 
    In the second case, we use size induction on the word, apply the original induction hypothesis to the prefix and the size induction hypothesis to the suffix. 
    We use two concatenation lemmas for $R$ to merge the sub-expression. 
    This finishes the proof.
\end{proof}

\paragraph{}
Formalizing theorem \ref{LR} requires infrastructure to deal with $allbutlast$. 
Once this is in place, we can formalize the concatenation lemmas for $R$ and $L$.
These are required later to connect sub-results. 

\code{tc_RcatL}{}{transitive_closure_R_catL_head}
\code{tc_LcatL}{}{transitive_closure_L_catL_head}
\code{tc_LcatR}{}{transitive_closure_L_catL_head}

\paragraph{}
We also need the splitting lemma mentioned earlier.
This is quite intricate. We could split right after the first character and thereby simplify the lemma. 
However, the current form has the advantage of requiring simple concatenation lemmas.

\code{tc_split}{}{transitive_closure_L_split_head}

\paragraph{}
These lemmas suffice to show the claim of theorem \ref{LR}.
\code{tc_RL*}{}{transitive_closure_R_L_star_head}
\code{tc_RL}{}{transitive_closure_R_L_head}
\code{tc_LR1}{}{transitive_closure_L_R_1_head}
\code{tc_LR}{}{transitive_closure_L_R_head}
\todo{Fix this mess}


\paragraph{} 




