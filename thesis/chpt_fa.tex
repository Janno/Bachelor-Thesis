
\chapter{Finite Automata}
\label{chap:FA}

Another way of characterizing regular languages are finite automata (FA)\cite{DBLP:books/daglib/0011126}. 
We will show that the languages of finite automata are exactly the regular languages. 
Furthermore, we will also derive a decision procedure for equivalence of regular expressions.

\section{Definition}
A finite automaton consists of
\begin{enumerate}
    \item
        finite set of states $Q$, 
    \item 
        a starting state $s \in Q$, 
    \item 
        a set of final states $F \subseteq Q$ 
    \item 
        and a state-transition relation $\delta$. 
\end{enumerate}

We define a \textbf{run} of a word $w \in \Sigma^*$ on an automaton $A = (Q, s, F, \delta)$ as a sequence of states $\sigma$ such that 
for every two consequetive positions $i,i+1$ in $\sigma$ there is 
$(\sigma_i, w_i, \sigma_{i+1}) \in \delta$.
A word $w$ is \textbf{accepted} by $A$ in state $x$ if and only if there exists a run $\sigma$ of $w$ on $A$ such that $\sigma_0 = x \, \wedge \, \sigma_{\vert\sigma\vert-1} \in F$.
The resulting set of accepted words is denoted by $\acc{x}{A}$.
The \textbf{language} of $A$ is exactly $\acc{s}{A}$ and is denoted $\lang{A}$. 

\subsection{Non-Deterministic Finite Automata}
Finite automata can be \textbf{non-deterministic} (NFA) in the sense that there exist multiple distinct runs for a word. 
This is the case if and only if $\delta$ is not functional.

\code{nfa}{Non-Deterministic Finite Automata}{automata_nfa}
\codeblock{nfa_accept}{}{automata_nfa_accept}
\codeblock{nfa_lang}{}{automata_nfa_lang}

\paragraph{}
The acceptance criterion given here avoids the matter of runs.
In many cases, this will help us with proofs by in induction on the accepted word.
However, we will need runs in some of the proofs.
Due to the fact that runs are not unique on NFAs, 
we give a predicate that decides if a run on $A$ is valid for a word $w$.
We then show that the acceptance criterion given above corresponds to the mathematical definition in terms of runs.

\code{nfa_run}{}{automata_nfa_run}
\codeblock{nfa_run_accept}{}{automata_nfa_run_accept_head}

\subsection{Deterministic Finite Automata}
For functional $\delta$, we speak of \textbf{deterministic} finite automata (DFA). 
In this case, we write $\delta$ as a function in our \coq\ development. 
%This allows us to define the acceptance criterion in terms of the unique sequence of transitions on the automaton. 

\code{dfa}{Deterministic Finite Automata}{automata_dfa}
\codeblock{dfa_accept'}{}{automata_dfa_accept}
\codeblock{dfa_lang}{}{automata_dfa_lang}

\paragraph{}
Again, we avoid runs in our formalization of the acceptance criterion in favor of a acceptance criterion that is easier to work with in proofs.
In this case, however, we can give a function that computes the unique run of a word on $A$.
This allows us to give an alternative acceptance criterion that is closer to the mathematical definition.
We also prove that both criteria are equivalent.

\code{dfa_run'}{}{automata_dfa_run'}
\codeblock{dfa_run_accept}{}{automata_dfa_run_accept_head}


%\paragraph{}
%We can give simpler formalizations of the acceptance on deterministic and non-deterministic automata.
%These will allow us to hide runs and runs as much as possible and instead work with a simple, inductive, boolean predicate.

%\code{automata_dfa_accept}{}{automata_dfa_accept}

\subsubsection{Equivalence of Automata}
\begin{definition}
    We say that two automata are \textbf{equivalent} if and only if their languages are equal.
\end{definition}

\subsubsection{Equivalence between DFA and NFA}
\paragraph{} 
Deterministic and non-deterministic finite automata are equally expressive. 
One direction is trivial since every DFA can be seen as a NFA. 
We prove the other direction using the powerset construction. 
Given NFA $A$, we construct an equivalent DFA $A_{det}$ in the following way:
%The new set of states is the powerset of the given NFA's set of states. 
%The new starting state is the singleton set containing the original starting state. 
%A state is final if and only if it contains an original final state. 
%The transition function on powerset states is defined as follows:

\begin{eqnarray*}
    Q_{det} & := & 2^Q \\ %\{P \; | \; P \subseteq Q\} \\
    {s}_{det} & := & \{ s \} \\
    F_{det} & := & \{ P \; | \; P \in Q_{det} \wedge P \cap F \neq \emptyset \} \\
    \delta_{det} & := & \{ (P,a,\bigcup \limits _{p \in P} \{ q \; | \; q \in Q, (p,a,q) \in \delta \}) \; | \; P \in Q_{det}, a \in \Sigma \}.     \\
    A_{det} &:=&  (Q_{det}, s_{det}, F_{det}, \delta_{det}).
\end{eqnarray*}

\paragraph{}
The formalization of $A_{det}$ is straight-forward. 
We leave the set of states \lstinline!{set A}! implicit.

\code{}{}{automata_nfa_to_dfa}

\begin{lemma}
    \label{nfa_to_dfa_complete}
    For all powerset states $X$ and for all states $x$ with $x \in X$ we have that
    \begin{equation*}
        \acc{x}{A} \subseteq \acc{X}{A_{det}}.
    \end{equation*}
\end{lemma}

\begin{proof}
    Let $w \in \acc{x}{A}$. We proof by induction on $w$ that $w \in \acc{X}{A_{det}}$. 
    \begin{itemize}
        \item
            For $w = \varepsilon$ and $\varepsilon \in \acc{x}{A}$ we get $x \in F$ from $\varepsilon \in \acc{x}{A}$. 
            From $x \in X$ we get $X \cap F \neq \emptyset$ and therefore $\varepsilon \in \acc{X}{A_{det}}$.
        \item
            For $w = a w'$ and $a w' \in \acc{x}{A}$ we get $y$ such that $w' \in \acc{y}{A}$ and $(x,a,y) \in \delta$.
            The latter gives us $y \in Y$ where $Y$ is such that $(X, a, Y) \in \delta_{det}$.
            With $y \in Y$ and $w' \in \acc{y}{A}$ we get 
            which gives us $w' \in \acc{Y}{A_{det}}$ by induction hypothesis.
            With $(X, a, Y) \in \delta_{det}$ we get $a w' \in \acc{X}{A_{det}}$.
    \end{itemize}
\end{proof}


\begin{lemma}
    \label{nfa_to_dfa_sound}
    For all powerset states $X$ and all words $w \in \acc{X}{A_{det}}$ there exists a state $x$ such that 
    \begin{equation*}
        x \in X \wedge
        w \in \acc{x}{A}.
    \end{equation*}
\end{lemma}

\begin{proof}
    We do an induction on $w \in \Sigma^*$. %that there exists $x$ such that $x \in X \wedge w \in \acc{x}{A}$. 
    \begin{itemize}
        \item
            For $w = \varepsilon$ and $\varepsilon \in \acc{X}{A_{det}}$ we get  $X \cap F \neq \emptyset$.
            Therefore, there exists $x$ such that $x \in X$ and $x \in F$.
            Thus, we have $\varepsilon \in \acc{x}{A}$.
        \item
            For $w = a w'$ and $a w' \in \acc{X}{A_{det}}$ we get $Y$ such that $w' \in \acc{Y}{A_{det}}$ and $(X,a,Y) \in \delta_{det}$.
            From the induction hypothesis we get $y$ such that $y \in Y$ and $w' \in \acc{y}{A}$.
            From $y \in Y$ and $(X, a, Y) \in \delta_{det}$ we get $x$ such that $x \in X$ and $(x, a, y) \in \delta$.
            Thus, $a w' \in \acc{x}{A}$.
    \end{itemize}
\end{proof}

\begin{theorem}
    The powerset automaton $A_{det}$ accepts the same language as $A$, i.e.
    \begin{equation*}        
        \lang{A} = \lang{A_{det}}.        
    \end{equation*}
\end{theorem}
\begin{proof}
    ``$\subseteq$'' 
    This follows directly from lemma \ref{nfa_to_dfa_complete} with $x = s$ and $X = {s}_{det}$.

    ``$\supseteq$''
    From lemma \ref{nfa_to_dfa_sound} with $X = {s}_{det}$ we get 
    $\acc{s_{det}}{A_{det}} \subseteq \acc{s}{A}$, which proves the claim.
\end{proof}

\paragraph{}
The formalization of this proof is straight-forward and follows the plan laid out above. 
The corresponding Lemmas are:
\code{powerset_complete}{}{automata_nfa_to_dfa_complete_head}
\codeblock{powerset_sound}{}{automata_nfa_to_dfa_sound_head}
\codeblock{powerset_correct}{}{automata_nfa_to_dfa_correct_head}


\section{Connected Components}
\paragraph{} 
Finite automata can have isolated subsets of states that are not reachable from the starting state. 
These states can not contribute to the language of the automaton since there are no runs from the starting state to any of those unreachable states.
It will later be useful to have automata that only contain reachable states. 
Therefore, we define a procedure to extract the connected component containing the starting state from a given automaton.

\begin{definition}
    \label{A_c}
    Let $A = (Q, s, F, \delta)$ be a DFA.
    We define $\mathrm{reachable1}$ such that for all x and y, 
    $(x,y) \in \mathrm{reachable1} \iff \exists a, (x,a,y) \in \delta$.
    We define $\mathrm{reachable} := \{y \; | \; (s,y) \in \mathrm{reachable1}^*\}$, 
    where $\mathrm{reachable1}^*$ denotes the transitive closure of $\mathrm{reachable1}$.
    With this, we can define the connected automaton $A_c$:
    \begin{eqnarray*}
        Q_c & := & Q \cap reachable \\
        s_c & := & s \\
        F_c & := & F \cap reachable \\
        \delta_c & := & \{(x, a, y) \; | \; (x, a, y) \in \delta \wedge x,y \in Q_c \} \\
        A_c &:=& (Q_c, s_c, F_c, \delta_c).
    \end{eqnarray*}
\end{definition}

\paragraph{}
We make use of \ssreflect's $connect$ predicate to extract a sequence of all states reachable from $s$. 
From this, we construct a finite type and use that as the new set of states. 
These new states carry a proof of reachability. %(\lstinline{ssvalP}).
We also have to give a transition function that ensures transitions always end in reachable states.

\code{automata_reachable1}{}{automata_reachable1}
\codeblock{automata_reachable}{}{automata_reachable}
\codeblock{automata_reachable0}{}{automata_reachable0_head}
\codeblock{automata_reachable_step}{}{automata_reachable_step_head}
\codeblock{automata_dfa_connected}{}{automata_dfa_connected}

\todo{Make this understandable}

\begin{lemma}
    \label{dfa_connected_correct'}
    For every state $x \in \mathrm{reachable}$ we have that
    \begin{equation*}
        \acc{x}{A_c} = \acc{x}{A}.
    \end{equation*}
\end{lemma}
\begin{proof}
    ``$\subseteq$'' Trivial.
    ``$\supseteq$''
    We do an induction on $w$.
    \begin{itemize}
        \item
            For $w = \varepsilon$ we have $\varepsilon \in \acc{x}{A}$ and therefore $x \in F$. 
            With $x \in reachable$ we get $x \in F_c$. 
            Thus, $\varepsilon \in \acc{x}{A_c}$.
        \item
            For $w = a w'$ we have have $y \in Q$ such that $(x, a, y) \in \delta$ and $w' \in \acc{y}{A}$.
            From $x \in \mathrm{reachable}$ we get $y \in \mathrm{reachable}$ by transitivity.
            Therefore, $(x,a,y) \in \delta_c$.
            The induction hypothesis gives us $w' \in \acc{y}{A_c}$. 
            Thus, $a w' \in \acc{x}{A_c}$.
    \end{itemize}
\end{proof}

\begin{theorem}
    \label{dfa_connected_correct}
    The language of the connected automaton $A_c$ is identical to that of the original automaton $A$, i.e.
    \begin{equation*}
        \lang{A} = \lang{A_c}.        
    \end{equation*}
\end{theorem}

\begin{proof}
    By reflexivity, we have $s \in \mathrm{reachable}$. 
    We use lemma \ref{dfa_connected_correct'} with $x = s$ to prove the claim.
        %Unreachable states have no influence on the language of an automaton because there is no run from the starting state that contains such a state.
\end{proof}

\paragraph{}
The formalization of lemma \ref{dfa_connected_correct'} and theorem \ref{dfa_connected_correct} is straight-forward.

\code{automata_dfa_connected_correct'}{}{automata_dfa_connected_correct'_head}
\codeblock{automata_dfa_connected_correct}{}{automata_dfa_connected_correct_head}

\paragraph{}
To make use of the fact that $A_c$ is fully connected, we will proof a characteristic property of $A_c$. 

\begin{definition}
    A \textbf{representative} of a state $x$ is a word $w$ such that the unique run of $w$ on $A_c$ ends in $x$.
\end{definition}

\begin{lemma}
    \label{dfa_connected_repr}
    We can give a representative for every state $x \in Q_c$.
    %\todo{Sigma?}
\end{lemma}

\begin{proof}
    $x$ carries a proof of reachability.
    From this, we get a path through the graph of $\mathrm{reachable1}$ that ends ind $x$.
    We build the representative by extracting the edges of the path and building a word from those.
    \todo{Choice?}
\end{proof}

\paragraph{}
The formalization of theorem \ref{dfa_connected_repr} includes a more general version of the theorem, 
which facilitates the proof by induction over the path.

\code{dfa_connected_repr'}{}{automata_dfa_connected_repr'_head}
\codeblock{}{}{automata_dfa_connected_repr_head}


\section{Emptiness}
\paragraph{}
Given an automaton $A$, we can check if $\lang{A} = \emptyset$. We simply obtain the connected automaton of $A$ and check if there are any final states left. 

\begin{theorem}
    \label{dfa_lang_empty}
    The language of the connected automaton $A_c$ is empty if and only if its set of final states $F_c$ is empty, i.e.
    \begin{equation*}
        \lang{A} = \emptyset \iff F_c = \emptyset.
    \end{equation*}
\end{theorem}

\begin{proof}
    By theorem \ref{dfa_connected_correct} we have $\lang{A} = \lang{A_c}$.
    Therefore, it suffices to show
    \begin{equation*}
        \lang{A_c} = \emptyset \iff F_c = \emptyset.
    \end{equation*}
    ``$\Leftarrow$''
    We have $\lang{A_c} = \emptyset$ and have to show that for all $x \in Q_c$, $x \notin F_c$.
    Let $x \in Q_c$. 
    By lemma \ref{dfa_connected_repr} we get $w$ such that the unique run of $w$ on $A_c$
    ends in $x$. 
    We use $\lang{A_c} = \emptyset$ to get $w \notin \lang{A_c}$, 
    which implies that the run of $w$ on $A_c$ ends in a non-final state.
    By substituting the last state of the run by $x$ we get $x \notin F_c$.
    ``$\Rightarrow$''
    We have $F_c = \emptyset$ and have to show that for all words $w$, $w \notin \lang{A_c}$.
    We use $F_c = \emptyset$ to show that the last state of the run of $w$ on $A_c$ is non-final.
    Thus, $w \notin \lang{A_c}$.

    Thus, emptiness is decidable.
\end{proof}


\paragraph{}
The formalization of lemma \ref{dfa_lang_empty} is split in two parts to facilitate its application. 

\code{}{}{automata_dfa_lang_empty}
\codeblock{dfa_lang_empty_complete}{}{automata_dfa_lang_empty_complete_head}
\codeblock{dfa_lang_empty_sound}{}{automata_dfa_lang_empty_sound_head}
\codeblock{dfa_lang_empty_correct}{}{automata_dfa_lang_empty_correct_head}



\section{Deciding Equivalence of Finite Automata}
Given finite automata $A_1$ and $A_2$, we construct DFA $A$ such that the language of $A$ is the symmetric difference of the languages of $A_1$ and $A_2$, i.e.,
\begin{equation*}          
    \lang{A} := \lang{A_1} \ominus \lang{A_2} = \lang{A_1} \cap \neg \lang{A_2} \cup \lang{A_2} \cap \neg \lang{A_1}.      
\end{equation*}
\begin{theorem} The equivalence of $A_1$ and $A_2$ is decidable, i.e.
    \label{dfa_sym_diff_correct}
    \begin{equation*}                
        \lang{A_1} = \lang{A_2} \mbox{ if and only if } \lang{A} \mbox{ is empty. }                
    \end{equation*}
\end{theorem}
\begin{proof}
    The correctness of this procedure follows from the properties of the symmetric difference operator, i.e.
    \begin{equation*}                  
        \lang{A_1} \ominus \lang{A_2} = \emptyset \Leftrightarrow \lang{A_1} = \lang{A_2}.                  
    \end{equation*}
    Thus, equivalence is decidable.    
\end{proof}

\code{}{Formalization of theorem \ref{dfa_sym_diff_correct}}{automata_dfa_sym_diff}
\codeblock{}{}{automata_dfa_sym_diff_correct_head}

\section{Regular Expressions and Finite Automata}

\paragraph{} 
We prove that there is a finite automaton for every extended regular expression and vice versa. 
In fact, we can give a standard regular expression for every finite automaton.
With this, we will prove that extended regular expressions are equivalent to standard regular expressions, 
thereby proving closure under intersection and negation.


\subsection{Regular Expressions to Finite Automata}

\paragraph{} 
We prove that there exists an equivalent automaton for every extended regular expression.
The structure of this proof is given by the inductive nature of regular expressions.
For every constructor, we provide an equivalent automaton.

\paragraph{}
Depending on the constructor of the regular expression, we will construct an equivalent DFA or NFA.
\lstinline{Void}, \lstinline{Eps}, \lstinline{Dot}, \lstinline{Atom}, \lstinline{Plus}, \lstinline{And} and \lstinline{Not} are very easy to implement on DFAs, whereas \lstinline{Star} and \lstinline{Conc} lend themselves well to NFAs.

\subsubsection{Void}
\begin{definition}
    We define an empty DFA with a single, non-accepting state, i.e.
    \begin{equation*}
        A_\emptyset := (\{t\}, t, \emptyset, \{(t, a, t) \; | \; a \in \Sigma\}).
    \end{equation*}
\end{definition}

\begin{lemma}
    \label{dfa_empty_correct}
    The language of the empty DFA is empty, i.e.
    \begin{equation*}
        \lang{E} = \emptyset.
    \end{equation*}
\end{lemma}

\begin{proof}
    $A_\emptyset$ has no final states, i.e. no run can end in a final state.
\end{proof}


\code{}{}{automata_dfa_void}
\codeblock{}{}{automata_dfa_void_correct_head}


\subsubsection{Eps}
\begin{definition}
    We define an automaton that accepts only the empty word, i.e.
    \begin{equation*}
        A_\varepsilon := (\{t, f\}, t, \{f\}, \{(x, a, f) \; | \; x \in \{t, f\}, a \in \Sigma\}).
    \end{equation*}
\end{definition}

\begin{lemma}
    \label{dfa_eps_correct'}
    $A_\varepsilon$ accepts no word in state $f$, i.e. for all w,
    \begin{equation*}
        w \notin \acc{f}{A_\varepsilon}.
    \end{equation*}
\end{lemma}
\begin{proof}
    Let $w \in \Sigma^*$.
    We do an induction on $w$. 
    For $w = \varepsilon$ we get $\varepsilon \notin \acc{f}{A_\varepsilon}$ by $f \notin F_\varepsilon$. 
    For $w = aw'$ we have $w' \notin \acc{f}{A_\varepsilon}$. 
    Furthermore, $(f, a, f) \in \delta_\varepsilon$.
    Therefore, $aw' \notin \acc{f}{A_\varepsilon}$.
\end{proof}

\begin{lemma}
    \label{dfa_eps_correct}
    The language of $A_\varepsilon$ is exactly the singleton set containing the empty word, i.e.
    \begin{equation*}
        \lang{A_\varepsilon} = \{\varepsilon\}.
    \end{equation*}
\end{lemma}

\begin{proof}
    Let $w \in \Sigma^*$.
    We do an induction on $w$. 
    For $w = \varepsilon$ we have $\varepsilon \in \lang{A_\varepsilon}$ and $\varepsilon \in \{\varepsilon\}$.
    Therefore, both directions are trivial.
    For $w = aw'$ we consider both directions independently. \\
    ``$\Rightarrow$'' We have $(t, a, f) \in \delta_\varepsilon$ and $w' \in \acc{f}{A_\varepsilon}$. By lemma \ref{dfa_eps_correct'}, this is a contradiction. \\
    ``$\Leftarrow$'' We get a straigt-forward contradiction from $aw' \in \{\varepsilon\}$.
\end{proof}

\code{}{}{automata_dfa_eps}
\codeblock{}{}{automata_dfa_eps_correct_head}
\todo{reflect?}


\subsubsection{Dot}
\begin{definition}
    We define an automaton that accepts the set of all singleton words, i.e.
    \begin{equation*}
        A_{Dot} := (\{s, t, f\}, s, \{t\}, 
        \{(s, a, t) \; | \; a \in \Sigma\}
        \; \cup \;
        \{(x, a, f) \; | \; x \in \{t, f\}, a \in \Sigma\}
        ).
    \end{equation*}
\end{definition}

\begin{lemma}
    \label{dfa_dot_correct''}
    $A_{Dot}$ does not accept any word in state $f$, i.e. $\acc{f}{A_{Dot}} = \emptyset$.
\end{lemma}
\begin{proof}
    We prove this by induction on $w \in \Sigma^*$. 
    For $w = \varepsilon$ we have $\varepsilon \notin \acc{f}{A_{Dot}}$ by $f \notin F_{Dot}$.
    For $w = aw'$ we have $(f, a, f) \in \delta_{Dot}$ and $w' \notin \acc{f}{A_{Dot}}$ by induction hypothesis.
    Thus, $aw' \notin \acc{f}{A_{Dot}}$.
\end{proof}

\begin{lemma}
    \label{dfa_dot_correct'}
    $A_{Dot}$ accepts exactly the empty word in state $t$, i.e. $\acc{t}{A_{Dot}} = \{\varepsilon\}$.
\end{lemma}
\begin{proof}
    Let $w \in \Sigma^*$. 
    We do a case distinction on $w$.
    For $w = \varepsilon$ we have $\varepsilon in \acc{t}{A_{Dot}}$ by $t \in F_{Dot}$. We also have $\varepsilon \in \{\varepsilon\}$.
    For $w = aw'$ we get $(t, a, f) \in \delta_{Dot}$. 
    Since $aw' \notin \{\varepsilon\}$ it suffices to show that 
    $w' \notin \acc{f}{A_{Dot}}$,
    which we have by lemma \ref{dfa_dot_correct''}.
\end{proof}

\code{}{}{automata_dfa_dot}
\codeblock{}{}{automata_dfa_dot_correct''_head}
\codeblock{}{}{automata_dfa_dot_correct'_head}
\codeblock{}{}{automata_dfa_dot_correct_head}
\todo{reflect?}

\subsubsection{Not}
\begin{definition}
    Given DFA $A=(Q,s,F,\delta)$, the complement automaton $A_\neg$ is constructed by switching accepting and non-accepting states, i.e.
    \begin{equation*}
       A_\neg := (Q,s,Q\backslash F,\delta). 
    \end{equation*}
\end{definition}

\begin{lemma}
    \label{dfa_compl_correct'}
    For every state $x \in Q$, we have that $w \in \Sigma^*$ is accepted in $x$ by $A_\neg$ if and only if it is not accepted in $x$ by $A$, i.e. $\acc{x}{A_\neg} = \Sigma^* \backslash \acc{x}{A}$ 
\end{lemma}
\begin{proof}
    We do an induction on $w$.
    For $w = \varepsilon$ we have $\varepsilon \in \acc{x}{A_\neg} \iff \varepsilon \in \acc{x}{A}$ from
    $x \in F \iff x \notin Q\backslash F$.
    For $w = aw'$ we get $(y,a,x) \in \delta$. 
    By induction hypothesis, $w' \in \acc{x}{A_\neg} \iff w' \notin \acc{x}{A}$
    Thus, $aw' \in \acc{y}{A_\neg} \iff aw' \notin \acc{y}{A}$.
\end{proof}
\begin{lemma}
    $A_\neg$ accepts the complement language of $A$, i.e. $\lang{A_\neg} = \Sigma^* \backslash \lang{A}$.
    \label{dfa_compl_correct}
\end{lemma}
\begin{proof}
    This follows directly from lemma \ref{dfa_compl_correct'} with $x = s$.
\end{proof}

\subsubsection{Plus}
\begin{definition}
    Given DFAs $A_1=(Q_1, s_1, F_1, \delta_1)$ and $A_2=(Q_2, s_2, F_2, \delta_2)$ we construct the disjunction automaton  in the following way:
    \begin{eqnarray*}
        Q_\vee &:=& Q_1 \times Q_2 \\
        s_\vee &:=& (s_1, s_2) \\
        F_\vee &:=& \{(x_1,x_2) \; | \; x_1 \in F_1 \vee x_2 \in F_2\} \\
        \delta_\vee &:=& \{( (x_1, x_2),a,(y_1, y_2)) \; | \; a \in \Sigma, (x_1, a, y_1) \in \delta_1, (x_2, a, y_2) \in \delta_2 \} \\
        A_\vee &:=& (Q_\vee, s_\vee, F_\vee, \delta_\vee).
    \end{eqnarray*}
\end{definition}

\begin{lemma}
    \label{dfa_disj_correct'}
    For every state $(x_1, x_2) \in Q_\vee$, we have that
    \begin{equation*}
        \acc{(x_1, x_2)}{A_\vee} = \acc{x_1}{A_1} \cup \acc{x_2}{A_2}.
    \end{equation*}
\end{lemma}
\begin{proof}
    We do a proof by induction on $w \in \Sigma^*$.
    For $w = \varepsilon$ we have, by definition of $F_\vee$, 
    $%\begin{equation*}
    \varepsilon \in \acc{(x_1, x_2)}{A_\vee} 
    \iff \varepsilon \in \acc{x_1}{A_1} \vee \varepsilon \in \acc{x_2}{A_2}.
    $%\end{equation*} 
    \\
    For $w = aw'$ we get $(x_1, a, y_1) \in \delta_1$ and $(x_2, a, y_2) \in \delta_2$.
    By induction hypothesis, we also have $w' \in \acc{x_1}{A_1} \vee w' \in \acc{x_2}{A_2}$.
    Thus, we get $aw' \in \acc{y_1}{A_1} \vee aw' \in \acc{x_2}{A_2}$.
\end{proof}

\begin{lemma}
    $\lang{A_\vee} = \lang{A_1} \cup \lang{A_2}$.
    \label{dfa_disj_correct}
\end{lemma}
\begin{proof}
    This follows directly from lemma \ref{dfa_disj_correct'} with $x = (s_1, s_2)$.
\end{proof}


\code{}{}{automata_dfa_disj}
\codeblock{}{}{automata_dfa_disj_correct'_head}
\codeblock{}{}{automata_dfa_disj_correct_head}


\subsubsection{And}
\begin{definition}
    Given DFAs 
    $A_1=(Q_1, s_1, F_1, \delta_1)$ and $A_2=(Q_2, s_2, F_2, \delta_2)$ 
    we construct the conjunction automaton  in the following way:
    \begin{eqnarray*}
        Q_\wedge &:=& Q_1 \times Q_2 \\
        s_\wedge &:=& (s_1, s_2) \\
        F_\wedge &:=& \{(x_1,x_2) \; | \; x_1 \in F_1 \wedge x_2 \in F_2\} \\
        \delta_\wedge &:=& \{( (x_1, x_2),a,(y_1, y_2)) \; | \; a \in \Sigma, (x_1, a, y_1) \in \delta_1, (x_2, a, y_2) \in \delta_2 \} \\
        A_\wedge &:=& (Q_\wedge, s_\wedge, F_\wedge, \delta_\wedge).
    \end{eqnarray*}
\end{definition}

\begin{lemma}
    \label{dfa_conj_correct'}
    For every state $(x_1, x_2) \in Q_\wedge$, we have that
    \begin{equation*}
        \acc{(x_1, x_2)}{A_\wedge} = \acc{x_1}{A_1} \cup \acc{x_2}{A_2}.
    \end{equation*}
\end{lemma}
\begin{proof}
    This proof is very similar to lemma \ref{dfa_disj_correct'}.
    We do a proof by induction on $w \in \Sigma^*$.
    For $w = \varepsilon$ we have, by definition of $F_\wedge$, 
    $%\begin{equation*}
    \varepsilon \in \acc{(x_1, x_2)}{A_\wedge} 
    \iff \varepsilon \in \acc{x_1}{A_1} \wedge \varepsilon \in \acc{x_2}{A_2}.
    $%\end{equation*} 
    \\
    For $w = aw'$ we get $(x_1, a, y_1) \in \delta_1$ and $(x_2, a, y_2) \in \delta_2$.
    By induction hypothesis, we also have $w' \in \acc{x_1}{A_1} \wedge w' \in \acc{x_2}{A_2}$.
    Thus, we get $aw' \in \acc{y_1}{A_1} \wedge aw' \in \acc{x_2}{A_2}$.
\end{proof}

\begin{lemma}
    $\lang{A_\wedge} = \lang{A_1} \cap \lang{A_2}$.
    \label{dfa_conj_correct}
\end{lemma}
\begin{proof}
    This follows directly from lemma \ref{dfa_conj_correct'} with $x = (s_1, s_2)$.
\end{proof}


\code{}{}{automata_dfa_conj}
\codeblock{}{}{automata_dfa_conj_correct'_head}
\codeblock{}{}{automata_dfa_conj_correct_head}


\subsubsection{Conc}
\begin{definition}
   Given two NFAs
    $A_1=(Q_1, s_1, F_1, \delta_1)$ and $A_2=(Q_2, s_2, F_2, \delta_2)$ 
    we construct the concatenation automaton in the following way:
    \begin{eqnarray*}
        Q_{Conc} &:=& Q_1 \; \dotcup \; Q_2 \\
        s_{Conc} &:=& s_1 \\
        F_{Conc} &:=&  \mathbf{TODO}\\
        \delta_{Conc} &:=& \delta_1 \; \cup \; \delta_2 \; \cup \; 
                         \{(x, a, y) \; | \; x \in Q_1, y \in Q_2, (s_2, a, y) \in \delta_2 \} \\
        %\{( (x_1, x_2),a,(y_1, y_2)) \; | \; a \in \Sigma, (x_1, a, y_1) \in \delta_1, (x_2, a, y_2) \in \delta_2 \} \\
        A_{Conc} &:=& (Q_{Conc}, s_{Conc}, F_{Conc}, \delta_{Conc}).
    \end{eqnarray*}\todo{Case dist. on $s_2 \in F_2$}
\end{definition}

\begin{lemma}
    \label{dfa_conc_cont}
    Every run of $A_2$ can be mapped to a run in $A_3$.
\end{lemma}
\begin{proof}
    Let $\sigma$ be a run starting in $x$ for $w \in \Sigma^*$ on $A_2$.
    We do an induction on $\sigma$.
    For $|\sigma| = 0$\todo{symbol for empty run}%
    we have $w = \varepsilon$.
    Therefore, we have that $\sigma$ is also a run starting in $x$ for $\varepsilon$ on $A_{Conc}$
    For $\sigma = y\sigma'$ we have $w = aw'$, $(x, a, y) \in \delta_2$.
    By definition of $\delta_{Conc}$ we also have $(x, a, y) \in \delta_{Conc}$.
    By induction hypothesis, we have that $\sigma'$ is a run for $w'$ starting in $y$ on $A_{Conc}$.
    Thus, $y\sigma'$ is a run for $aw'$ starting in $x$ on $A_{Conc}$.
\end{proof}

\todo{Include all proofs}

\subsection{Deciding Equivalence of Regular Expressions}

\paragraph{} 
Based on our procedure to construct an equivalent automaton from a regular expression, we can decide equivalence of regular expressions. Given $r_1$ and $r_2$, we construct equivalent DFA $A_1$ and $A_2$ as above.


\subsection{Finite Automata to Regular Expressions}
We prove that there is an equivalent standard regular expression for every finite automaton.
There are three ways to prove this. 

\paragraph{}
The first one is a method called ``\textbf{state removal}'' \cite{SignalFlow} (reformulated in \cite{springerlink:10.1007/978-3-540-30500-2}),
which works by sequentially building up regular expressions on the edges between states. 
In every step, one state is removed and its adjacent states' edges are updated to incorporate the missing state into the regular expression.
Finally, only two states remain. The resulting edges can be combined to form a regular expression that recognizes the language of the initial automaton.

\paragraph{}
The second method is known as ``\textbf{Brzozowski's method}'' \cite{DBLP:journals/jacm/Brzozowski64} and builds upon Brzowoski derivates of regular expressions.
This method is algebraic in nature and arrivates at a regular expression by solving a system of linear equations on regular expressions. 
Every state is assigned an unkown regular expression. 
The intuition of these unkown regular expressions is that they recognize the words accepted in their associated state. 
The system is solved by substituition and Arden's lemma \cite{DBLP:conf/focs/Arden61}.
The regular expressions associated with the starting state recognizes the language of the automaton.

\paragraph{}
The third method, which we chose for our development, is due to Kleene \cite{KleeneNets}.
It is known as the ``\textbf{transitive closure method}''.
This method recursively constructs a regular expression that is equivalent to the given automaton.
For the remainder of the chapter, we assume that we are given a DFA $A=(Q,s,F,\delta)$.

\paragraph{}
The idea of the transitive closure method is that we can give a regular expression to describe the path between any two states $x$ and $y$.
This regular expression accepts all words whose run $\sigma$ on $A$ starting in $x$ ends in $y$.
In fact, we can even give such a regular expression if we limit the set of paths through which the run is allowed to pass. 
We will call this set $X$.
Passing through, here, means that the restriction applies only to states that are traversed, 
i.e. not to the beginning or end of the run.

\paragraph{}
If we take $X$ to be the empty set, we only consider two types of runs.
First, if $x \neq y$, every transition from $x$ to $y$ constitutes one (singelton) word. 
Conversely, if there is a word which does not pass through a state and whose run on $A$ starts in $x$ and ends in $y$, 
it can only be a singleton word consisting of one of the transitions from $x$ to $y$.
Therefore, the corresponding regular expression is the disjunction of all transitions from $x$ to $y$. 
These transitions constitutes all possible words that lead from $x$ to $y$ without passing through any state.

Otherweise, if $x = y$, we also have to consider the empty word, since its run on $A$ starts in $x$ and ends in $y$.
Thus, the corresponding regular expression is the disjunction of all transitions from $x$ to $y$ \textbf{and} $\varepsilon$.

\paragraph{}
In the case of a non-empty $X$, we make the following observation. 
If we pick an element $z \in X$, then any run $\sigma$ from $x$ to $y$ either passes through $z$, or does not pass through $z$.
If it does, we can split it into three parts.
\begin{enumerate}[label=(\roman*)]
    \item  \label{R_xz}
        The first part contains the prefix of $\sigma$ which contains all states up to the first occurrence of $z$ that is not the starting state.
    \item  \label{R_zz}
        The second part contains that part of the remainder of $\sigma$ which contains all further occurences of $z$, though not the last state if that is $z$.
    \item  \label{R_zy}
        The third part contains the remainder.
\end{enumerate}

Parts \ref{R_xz} and \ref{R_zy} can easily be expressed in terms of $X\backslash\{z\}$.
Part \ref{R_zz} can be further decomposed into runs from $z$ to $z$ that do not pass through $z$.
Thus, part \ref{R_zz} can also be expressed in terms of $X\backslash\{z\}$ with the help of the $\ ^*$ operator.

If $\sigma$ does not pass through $z$, it is covered by the regular expression for pathes from $x$ to $y$ restricted to $X\backslash\{z\}$.


\begin{definition}
    \label{R}
    Let $X \subseteq Q$. Let $x, y \in Q$.
    We define R recursively on \todo{correct?}$|X|$:
    \begin{equation*}
        R^X_{x,y} := \left\{  
                \begin{array}{ll}
                    \vphantom{ \sum\limits_{ \substack{ a \in \Sigma\\ (x,a,y) \in \delta \\ b \in \Sigma } } }
                    \sum\limits_{
                        \substack{
                            a \in \Sigma\\
                            (x,a,y) \in \delta
                        }
                    } a 
                    & \mbox{if } X = \emptyset \wedge x != y; \\
                    \vphantom{ \sum\limits_{ \substack{ a \in \Sigma\\ (x,a,y) \in \delta \\ b \in \Sigma } } }
                    \sum\limits_{
                        \substack{
                            a \in \Sigma\\
                            (x,a,y) \in \delta
                        }
                    } a + \varepsilon 
                    & \mbox{if } X = \emptyset \wedge x = y; \\
                     R^{X\backslash\{z\}}_{x,z} (R^{X\backslash\{z\}}_{z,z})^* R^{X\backslash\{z\}}_{z,y} + R^{X\backslash\{z\}}_{x,y}.
                     & \mbox{if } \exists z \in X.
                \end{array}
            \right.
    \end{equation*}
\end{definition}

Based on the intuition given above, we try to express $\lang{A}$ by $R^Q$.
Based on the observation that every accepted word has a run from $s$ to some state $f \in F$, 
we only have to combine the corresponding regular expressions $R^Q_{s,f}$ to form a regular expression for $\lang{A}$.
The goal of this chapter is to prove the following theorem. 

\begin{theorem}
    \label{R_L} $\lang{A}$ is recognizable by a regular expression, i.e.
    \begin{equation*}
        \lang{\sum\limits_{f \in F} R^Q_{s,f}} = \lang{A}.
    \end{equation*}
\end{theorem}

We will first give a 
