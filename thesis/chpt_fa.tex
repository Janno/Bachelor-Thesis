
\chapter{Finite Automata}
\label{chap:FA}

Another way of characterizing regular languages are finite automata (FA)\cite{DBLP:books/daglib/0011126}. 
We will show that the languages of finite automata are exactly those recognized by regular expressions.
Furthermore, we will also derive a decision procedure for emptiness of an automaton's language.
Based on that, we will give a decision procedure for equivalence of regular expressions.
Finally, we prove that extended regular expressions and standard regular expressions are equally expressive 
and, thereby, that extended regular expressions are equivalent to regular languages.

\section{Definition}
A finite automaton consists of
\begin{enumerate}
    \item
        finite set of states $Q$, 
    \item 
        a starting state $s \in Q$, 
    \item 
        a set of final states $F \subseteq Q$ 
    \item 
        and a state-transition relation $\delta$. 
\end{enumerate}

We define a \textbf{run} of a word $w \in \Sigma^*$ on an automaton $A = (Q, s, F, \delta)$ as a sequence of states $\sigma$ such that 
for every two consecutive positions $i,i+1$ in $\sigma$ we have 
$(\sigma_i, w_i, \sigma_{i+1}) \in \delta$.
A word $w$ is \textbf{accepted} by $A$ in state $x$ if and only if there exists a run $\sigma$ of $w$ on $A$ such that $\sigma_0 = x \, \wedge \, \sigma_{\vert\sigma\vert-1} \in F$.
The resulting set of accepted words is denoted by $\acc{x}{A}$.
The \textbf{language} of $A$ is exactly $\acc{s}{A}$ and is denoted $\lang{A}$. 

\subsection{Non-Deterministic Finite Automata}
Finite automata can be \textbf{non-deterministic} (NFA) in the sense that there may exist multiple distinct runs for a word. 

\code{}{}{automata_nfa}
\codeblock{}{}{automata_nfa_accept}
\codeblock{}{}{automata_nfa_lang}


The acceptance criterion given here avoids the matter of runs.
In many cases, this will help us with proofs by induction on the accepted word.
However, we will need runs in some of the proofs.
Due to the fact that runs are not unique on NFAs, 
we give a predicate that decides if a sequence of states is a run on $A$ for a word $w$.
We then show that the acceptance criterion given above corresponds to the mathematical definition in terms of runs.

\code{nfa_run}{}{automata_nfa_run}
\codeblock{nfa_run_accept}{}{automata_nfa_run_accept_head}

\subsection{Deterministic Finite Automata}
For functional $\delta$, we speak of \textbf{deterministic} finite automata (DFA). 
In this case, we write $\delta$ as a function in our \coq\ development. 
%This allows us to define the acceptance criterion in terms of the unique sequence of transitions on the automaton. 

\code{dfa}{Deterministic Finite Automata}{automata_dfa}
\codeblock{dfa_accept'}{}{automata_dfa_accept}
\codeblock{dfa_lang}{}{automata_dfa_lang}


Again, we avoid runs in our formalization of the acceptance criterion in favor of an acceptance criterion that is easier to work with in proofs.
In this case, however, we can give a function that computes the unique run of a word on $A$.
This allows us to give an alternative acceptance criterion that is closer to the mathematical definition.
We also prove that both criteria are equivalent.

\code{dfa_run'}{}{automata_dfa_run'}
\codeblock{dfa_run_accept}{}{automata_dfa_run_accept_head}


%
%We can give simpler formalizations of the acceptance on deterministic and non-deterministic automata.
%These will allow us to hide runs and runs as much as possible and instead work with a simple, inductive, boolean predicate.

%\code{automata_dfa_accept}{}{automata_dfa_accept}

\subsubsection{Equivalence of Automata}
\begin{definition}
    We say that two automata are \textbf{equivalent} if and only if their languages are equal.
\end{definition}

\section{Equivalence of DFA and NFA}
 
Deterministic and non-deterministic finite automata are equally expressive. 
One direction is trivial since every DFA can be seen as an NFA. 
%The new set of states is the powerset of the given NFA's set of states. 
%The new starting state is the singleton set containing the original starting state. 
%A state is final if and only if it contains an original final state. 
%The transition function on powerset states is defined as follows:

\begin{theorem}
    \label{dfa_to_nfa}
    Let $A=(Q,s,F,\delta)$ be a DFA. Then $A$ is also an NFA.
\end{theorem}
\begin{proof}
    $(Q,s,F,\delta)$ fulfills the definition of an NFA. Thus, A \textit{is} an NFA.
\end{proof}

Formally, we have to construct an equivalent NFA, since DFAs and NFAs are different types.
The construction is straight-forward.
\code{}{}{automata_dfa_to_nfa}
\codeblock{}{}{automata_dfa_to_nfa_correct_head}

We prove the other direction using the powerset construction. 

\begin{definition}
Given NFA $A$, we construct an equivalent DFA $A_{det}$ in the following way:
\begin{eqnarray*}
    Q_{det} & := & \{P \; | \; P \subseteq Q\} \\
    {s}_{det} & := & \{ s \} \\
    F_{det} & := & \{ P \in Q_{det} \; | \; P \cap F \neq \emptyset \} \\
    \delta_{det} & := & \{ (P,a,\bigcup \limits _{p \in P} \{ q \in Q \; | \; (p,a,q) \in \delta \}) \; | \; P \in Q_{det}, a \in \Sigma \}.     \\
    A_{det} &:=&  (Q_{det}, s_{det}, F_{det}, \delta_{det}).
\end{eqnarray*}
\end{definition}

The formalization of $A_{det}$ is straight-forward. 
%We leave the set of states \lstinline_{set A}_ implicit.
The set of states is an implicit argument of the DFA constructor and thus not shown.

\code{}{}{automata_nfa_to_dfa}

\begin{lemma}
    \label{nfa_to_dfa_aux2}
    For all powerset states $X$ and for all states $x$ with $x \in X$ we have that
    \begin{equation*}
        \acc{x}{A} \subseteq \acc{X}{A_{det}}.
    \end{equation*}
\end{lemma}

\begin{proof}
    Let $w \in \acc{x}{A}$. We prove by induction on $w$ that $w \in \acc{X}{A_{det}}$. 
    \begin{itemize}
        \item
            For $w = \varepsilon$ and $\varepsilon \in \acc{x}{A}$ we get $x \in F$ from $\varepsilon \in \acc{x}{A}$. 
            From $x \in X$ we get $X \cap F \neq \emptyset$ and therefore $\varepsilon \in \acc{X}{A_{det}}$.
        \item
            For $w = a w'$ and $a w' \in \acc{x}{A}$ we get $y$ such that $w' \in \acc{y}{A}$ and $(x,a,y) \in \delta$.
            The latter gives us $y \in Y$ where $Y$ is such that $(X, a, Y) \in \delta_{det}$.
            With $y \in Y$ and $w' \in \acc{y}{A}$ we get $w' \in \acc{Y}{A_{det}}$ by inductive hypothesis.
            With $(X, a, Y) \in \delta_{det}$ we get $a w' \in \acc{X}{A_{det}}$.
    \end{itemize}
\end{proof}


\begin{lemma}
    \label{nfa_to_dfa_aux1}
    For all powerset states $X$ and all words $w \in \acc{X}{A_{det}}$ there exists a state $x$ such that 
    \begin{equation*}
        x \in X \wedge
        w \in \acc{x}{A}.
    \end{equation*}
\end{lemma}

\begin{proof}
    By induction on $w$. %that there exists $x$ such that $x \in X \wedge w \in \acc{x}{A}$. 
    \begin{itemize}
        \item
            For $w = \varepsilon$ and $\varepsilon \in \acc{X}{A_{det}}$ we get  $X \cap F \neq \emptyset$.
            Therefore, there exists $x$ such that $x \in X$ and $x \in F$.
            Thus, we have $\varepsilon \in \acc{x}{A}$.
        \item
            For $w = a w'$ and $a w' \in \acc{X}{A_{det}}$ we get $Y$ such that $w' \in \acc{Y}{A_{det}}$ and $(X,a,Y) \in \delta_{det}$.
            From the inductive hypothesis we get $y$ such that $y \in Y$ and $w' \in \acc{y}{A}$.
            From $y \in Y$ and $(X, a, Y) \in \delta_{det}$ we get $x$ such that $x \in X$ and $(x, a, y) \in \delta$.
            Thus, $a w' \in \acc{x}{A}$.
    \end{itemize}
\end{proof}

\begin{theorem}
    \label{nfa_to_dfa}
    The powerset automaton $A_{det}$ accepts the same language as $A$, i.e.
    \begin{equation*}        
        \lang{A} = \lang{A_{det}}.        
    \end{equation*}
\end{theorem}
\begin{proof}
    ``$\subseteq$'' 
    This follows directly from Lemma \ref{nfa_to_dfa_aux2} with $x := s$ and $X := {s}_{det}$.

    ``$\supseteq$''
    From Lemma \ref{nfa_to_dfa_aux1} with $X = {s}_{det}$ we get 
    $\acc{s_{det}}{A_{det}} \subseteq \acc{s}{A}$, which proves the claim.
\end{proof}


The formalization of this proof is straight-forward and follows the plan laid out above. 
The corresponding Lemmas are:
\code{powerset_aux2}{}{automata_nfa_to_dfa_aux2_head}
\codeblock{powerset_aux1}{}{automata_nfa_to_dfa_aux1_head}
\codeblock{powerset_correct}{}{automata_nfa_to_dfa_correct_head}


\section{Connected Components}
 
Finite automata can have isolated subsets of states that are not reachable from the starting state. 
Removing these states does not change the language.
%can not contribute to the language of the automaton since there are no runs from the starting state to any of those unreachable states.
It will later be useful to have automata that only contain reachable states. 
Therefore, we define a procedure to extract the connected component containing the starting state from a given automaton.

\begin{definition}
    \label{A_c}
    Let $A = (Q, s, F, \delta)$ be a DFA.
    We define $\mathrm{reachable1}$ such that for all x and y, 
    $(x,y) \in \mathrm{reachable1} \iff \exists a, (x,a,y) \in \delta$.
    We define $\mathrm{reachable} := \{y \; | \; (s,y) \in \mathrm{reachable1}^*\}$, 
    where $\mathrm{reachable1}^*$ denotes the transitive closure of $\mathrm{reachable1}$.
    With this, we can define the connected automaton $A_c$:
    \begin{eqnarray*}
        Q_c & := & Q \cap reachable \\
        s_c & := & s \\
        F_c & := & F \cap reachable \\
        \delta_c & := & \{(x, a, y) \; | \; (x, a, y) \in \delta \wedge x,y \in Q_c \} \\
        A_c &:=& (Q_c, s_c, F_c, \delta_c).
    \end{eqnarray*}
\end{definition}


We make use of \ssreflect's $connect$ predicate to extract a sequence of all states reachable from $s$. 
From this, we construct a finite type and use that as the new set of states. 
These new states carry a proof of reachability. %(\lstinline{ssvalP}).
We also have to give a transition function which ensures that transitions always end in reachable states.

\code{automata_reachable1}{}{automata_reachable1}
\codeblock{automata_reachable}{}{automata_reachable}
\codeblock{automata_reachable0}{}{automata_reachable0_head}
\codeblock{automata_reachable_step}{}{automata_reachable_step_head}
\codeblock{automata_dfa_connected}{}{automata_dfa_connected}

\begin{lemma}
    \label{dfa_connected_correct'}
    For every state $x \in \mathrm{reachable}$ we have that
    \begin{equation*}
        \acc{x}{A_c} = \acc{x}{A}.
    \end{equation*}
\end{lemma}
\begin{proof}
    ``$\subseteq$'' Trivial.
    ``$\supseteq$''
    By induction on $w$.
    \begin{itemize}
        \item
            For $w = \varepsilon$ we have $\varepsilon \in \acc{x}{A}$ and therefore $x \in F$. 
            With $x \in reachable$ we get $x \in F_c$. 
            Thus, $\varepsilon \in \acc{x}{A_c}$.
        \item
            For $w = a w'$ we have $y \in Q$ such that $(x, a, y) \in \delta$ and $w' \in \acc{y}{A}$.
            From $x \in \mathrm{reachable}$ we get $y \in \mathrm{reachable}$ by transitivity.
            Therefore, $(x,a,y) \in \delta_c$.
            The inductive hypothesis gives us $w' \in \acc{y}{A_c}$. 
            Thus, $a w' \in \acc{x}{A_c}$.
    \end{itemize}
\end{proof}

\begin{theorem}
    \label{dfa_connected_correct}
    The language of the connected automaton $A_c$ is identical to that of the original automaton $A$, i.e.
    \begin{equation*}
        \lang{A} = \lang{A_c}.        
    \end{equation*}
\end{theorem}

\begin{proof}
    By reflexivity, we have $s \in \mathrm{reachable}$. 
    We use Lemma \ref{dfa_connected_correct'} with $x := s$ to prove the claim.
        %Unreachable states have no influence on the language of an automaton because there is no run from the starting state that contains such a state.
\end{proof}


The formalization of Lemma \ref{dfa_connected_correct'} and Theorem \ref{dfa_connected_correct} is straight-forward.

\code{automata_dfa_connected_correct'}{}{automata_dfa_connected_correct'_head}
\codeblock{automata_dfa_connected_correct}{}{automata_dfa_connected_correct_head}


To make use of the fact that $A_c$ is fully connected, we will prove a characteristic property of $A_c$. 
We will need this property of $A_c$ in Chapter \ref{chap:MN}.


\begin{definition}
    A \textbf{representative} of a state $x$ is a word $w$ such that the unique run of $w$ on $A_c$ ends in $x$.
\end{definition}

\begin{lemma}
    \label{dfa_connected_repr}
    There is a representative for every state $x \in Q_c$.
\end{lemma}

\begin{proof}
    $x$ carries a proof of reachability.
    From this, we get a path through the graph of $\mathrm{reachable1}$ that ends in $x$.
    We build the representative by extracting the edges of the path and building a word from those.
\end{proof}


%The formalization of Theorem \ref{dfa_connected_repr} includes a more general version of the theorem, 
%which facilitates the proof by induction over the path.

%\code{dfa_connected_repr'}{}{automata_dfa_connected_repr'_head}
\codeblock{}{}{automata_dfa_connected_repr_head}


\section{Emptiness}

Given an automaton $A$, we can check if $\lang{A} = \emptyset$. We simply obtain the connected automaton of $A$ and check if there are any final states left. 

\begin{theorem}
    \label{dfa_lang_empty}
    The language of the connected automaton $A_c$ is empty if and only if its set of final states $F_c$ is empty, i.e.
    \begin{equation*}
        \lang{A} = \emptyset \iff F_c = \emptyset.
    \end{equation*}
\end{theorem}

\begin{proof}
    By Theorem \ref{dfa_connected_correct} we have $\lang{A} = \lang{A_c}$.
    Therefore, it suffices to show
    \begin{equation*}
        \lang{A_c} = \emptyset \iff F_c = \emptyset.
    \end{equation*}
    ``$\Rightarrow$''
    We have $\lang{A_c} = \emptyset$ and have to show that for all $x \in Q_c$, $x \notin F_c$.
    Let $x \in Q_c$. 
    By Lemma \ref{dfa_connected_repr} we get $w$ such that the unique run of $w$ on $A_c$
    ends in $x$. 
    We use $\lang{A_c} = \emptyset$ to get $w \notin \lang{A_c}$, 
    which implies that the run of $w$ on $A_c$ ends in a non-final state.
    By substituting the last state of the run by $x$ we get $x \notin F_c$.

    ``$\Leftarrow$''
    We have $F_c = \emptyset$ and have to show that for all words $w$, $w \notin \lang{A_c}$.
    We use $F_c = \emptyset$ to show that the last state of the run of $w$ on $A_c$ is non-final.
    Thus, $w \notin \lang{A_c}$.

\end{proof}

    Thus, emptiness is decidable.


%The formalization of Lemma \ref{dfa_lang_empty} is split in two parts to facilitate its application. 

\code{}{}{automata_dfa_lang_empty}
%\codeblock{dfa_lang_empty_aux2}{}{automata_dfa_lang_empty_aux2_head}
%\codeblock{dfa_lang_empty_aux1}{}{automata_dfa_lang_empty_aux1_head}
\codeblock{dfa_lang_empty_correct}{}{automata_dfa_lang_empty_correct_head}



\section{Deciding Equivalence of Finite Automata}
Given finite automata $A_1$ and $A_2$, we construct DFA $A$ such that the language of $A$ is the symmetric difference of the languages of $A_1$ and $A_2$, i.e.,
\begin{equation*}          
    \lang{A} := \lang{A_1} \ominus \lang{A_2} = \lang{A_1} \cap \neg \lang{A_2} \cup \lang{A_2} \cap \neg \lang{A_1}.      
\end{equation*}
\begin{theorem} The equivalence of $A_1$ and $A_2$ is decidable, i.e.
    \label{dfa_equiv_correct}
    \begin{equation*}                
        \lang{A_1} = \lang{A_2} \mbox{ if and only if } \lang{A} \mbox{ is empty. }                
    \end{equation*}
\end{theorem}
\begin{proof}
    The correctness of this procedure follows from the properties of the symmetric difference operator, i.e.
    \begin{equation*}                  
        \lang{A_1} \ominus \lang{A_2} = \emptyset \Leftrightarrow \lang{A_1} = \lang{A_2}.                  
    \end{equation*}
\end{proof}

    Thus, equivalence is decidable.    

\code{}{}{automata_dfa_sym_diff}
\codeblock{}{}{automata_dfa_equiv}
\codeblock{}{}{automata_dfa_equiv_correct_head}

%\section{Regular Expressions and Finite Automata}

 
%We prove that there is a finite automaton for every extended regular expression and vice versa. 
%In fact, we can give a standard regular expression for every finite automaton.
%With this, we will prove that extended regular expressions are equivalent to standard regular expressions, 
%thereby proving closure under intersection and negation.


\section{Regular Expressions to Finite Automata}
We prove that there exists an equivalent automaton for every extended regular expression.
The structure of this proof is given by the inductive nature of regular expressions.
%For every constructor, we provide an equivalent automaton.

\begin{theorem}
    \label{re_to_dfa}
    Let $r$ be an extended regular expression on $\Sigma$. Then we can give DFA $A$ such that
    \begin{equation*}
        \lang{r} = \lang{A}.
    \end{equation*}
\end{theorem}

Depending on the constructor of the regular expression, we will construct a corresponding operation on DFAs or NFAs.
\lstinline{Void}, \lstinline{Eps}, \lstinline{Dot}, \lstinline{Atom}, \lstinline{Plus}, \lstinline{And} and \lstinline{Not} are very easy to implement on DFAs, whereas \lstinline{Star} and \lstinline{Conc} lend themselves well to NFAs.

We show our implementation for \lstinline{Void}, \lstinline{Not}, and \lstinline{Conc}.
We also give a short overview of the automaton corresponding to \lstinline{Star}. 


\subsection{Void}
\begin{definition}
    We define an empty DFA with a single, non-accepting state, i.e.
    \begin{equation*}
        A_\emptyset := (\{t\}, t, \emptyset, \{(t, a, t) \; | \; a \in \Sigma\}).
    \end{equation*}
\end{definition}

\begin{lemma}
    \label{dfa_empty_correct}
    The language of the empty DFA is empty, i.e.
    \begin{equation*}
        \lang{E} = \emptyset.
    \end{equation*}
\end{lemma}

\begin{proof}
    $A_\emptyset$ has no final states, i.e. no run can end in a final state.
\end{proof}


\code{}{}{automata_dfa_void}
\codeblock{}{}{automata_dfa_void_correct_head}


\subsection{Not}
\begin{definition}
    Given DFA $A=(Q,s,F,\delta)$, the complement automaton $A_\neg$ is constructed by swapping accepting and non-accepting states, i.e.
    \begin{equation*}
       A_\neg := (Q,s,Q\backslash F,\delta). 
    \end{equation*}
\end{definition}

\begin{lemma}
    \label{dfa_compl_correct'}
    For every state $x \in Q$, we have that $w \in \Sigma^*$ is accepted in $x$ by $A_\neg$ if and only if it is not accepted in $x$ by $A$, i.e. $\acc{x}{A_\neg} = \Sigma^* \backslash \acc{x}{A}$ 
\end{lemma}
\begin{proof}
    By induction on $w$.
    For $w = \varepsilon$ we have $\varepsilon \in \acc{x}{A_\neg} \iff \varepsilon \in \acc{x}{A}$ from
    $x \in F \iff x \notin Q\backslash F$.
    For $w = aw'$ we get $(y,a,x) \in \delta$. 
    By inductive hypothesis, $w' \in \acc{x}{A_\neg} \iff w' \notin \acc{x}{A}$.
    Thus, $aw' \in \acc{y}{A_\neg} \iff aw' \notin \acc{y}{A}$.
\end{proof}
\begin{lemma}
    $A_\neg$ accepts the complement language of $A$, i.e. $\lang{A_\neg} = \Sigma^* \backslash \lang{A}$.
    \label{dfa_compl_correct}
\end{lemma}
\begin{proof}
    This follows directly from Lemma \ref{dfa_compl_correct'} with $x := s$.
\end{proof}


\subsection{Conc}
The most common approach to build the concatenation automaton is to connect
the final states of the first automaton to the starting state of the second automaton
by an $\varepsilon$-translation. 
We do not allow $\varepsilon$-transitions in our automata. 
The reason for this is that we do not want to lose the direct correspondence 
of the length of the word to the length of its run on an automaton.
Thus, in order to build the concatenation automaton, we duplicate all edges from
the starting state of the second automaton and add them to all final states 
of the first automaton.
Since the final states may already have edges with the same labels, 
we chose to implement this operation on NFAs.

\begin{definition}
   Given two NFAs
    $A_1=(Q_1, s_1, F_1, \delta_1)$ and $A_2=(Q_2, s_2, F_2, \delta_2)$ 
    we construct the concatenation automaton in the following way:
    %\begin{eqnarray*}
    \begin{align*}
        Q_{Conc} &:= Q_1 \; \dotcup \; Q_2 \\
        s_{Conc} &:= s_1 \\
        F_{Conc} &:= 
            \begin{cases}
                \begin{array}{ll}
                    F_2 & \mbox{ if } s_2 \notin F_2 \\
                    F_2 \cup F_1 & \mbox{ if } s_2 \in F_2
                \end{array}
            \end{cases}
        \\ %\mathbf{TODO}\\
        \delta_{Conc} &:= \delta_1 \; \cup \; \delta_2 \; \cup \; 
                         \{(x, a, y) \; | \; x \in Q_1, y \in Q_2, (s_2, a, y) \in \delta_2 \} \\
        %\{( (x_1, x_2),a,(y_1, y_2)) \; | \; a \in \Sigma, (x_1, a, y_1) \in \delta_1, (x_2, a, y_2) \in \delta_2 \} \\
        A_{Conc} &:= (Q_{Conc}, s_{Conc}, F_{Conc}, \delta_{Conc}).
    \end{align*}
    %\end{eqnarray*}
\end{definition}

\code{}{}{automata_nfa_conc}

Before we prove the correctness of $A_{Conc}$, we need a number of auxiliary lemmas.

\begin{lemma}
    \label{nfa_conc_cont}
    Every run of $A_2$ can be mapped to a run in $A_{Conc}$.
\end{lemma}
\begin{proof}
    Let $\sigma$ be a run starting in $x$ for $w \in \Sigma^*$ on $A_2$.
    By induction on $\sigma$.
    \begin{enumerate}
        \item 
            For $\sigma = x$
            we have $w = \varepsilon$.
            Therefore, we have that $\sigma$ is also a run starting in $x$ for $\varepsilon$ on $A_{Conc}$.
        \item
            For $\sigma = xy\sigma'$ we have $w = aw'$, $(x, a, y) \in \delta_2$.
            By definition of $\delta_{Conc}$ we also have $(x, a, y) \in \delta_{Conc}$.
            By inductive hypothesis, we have that $y\sigma'$ is a run for $w'$ starting in $y$ on $A_{Conc}$.
            Thus, $xy\sigma'$ is a run for $aw'$ starting in $x$ on $A_{Conc}$.
    \end{enumerate}
\end{proof}

\code{}{}{automata_nfa_conc_cont_head}

The next lemma shows that, in $A_{Conc}$, the final states of $A_1$ have all transitions that the starting state of $A_2$ also has.
Consequently, they accept the same words.

\begin{lemma}
    \label{nfa_conc_fin1}
    Let $x \in F_1$. Let $w \in \lang{A_2}$. Then $w \in \acc{x}{A_{Conc}}$.
\end{lemma}
\begin{proof}
    By induction on $w$. 
    \begin{enumerate}
        \item For $w = \varepsilon$ we have get $s \in F_2$ by $\varepsilon \in \lang{A_2}$ and, thus, $x \in F_{Conc}$ by definition.
        \item For $w = aw'$ we have $y \in Q_2$ such that $(s,a,y) \in \delta_2$ and thus $(x,a,y) \in \delta_{Conc}$.
            %By inductive hypothesis we have $w \in \acc{y}{A_{Conc}}$.
            We also have $w' \in \acc{y}{A_2}$ and thus, by Lemma \ref{nfa_conc_cont}, $w' \in \acc{y}{A_{Conc}}$.
            Thus, $aw' \in \acc{x}{A_{Conc}}$.
    \end{enumerate}
\end{proof}

\code{}{}{automata_nfa_conc_fin1_head}

The following lemma is one direction of the proof of correctness of $A_{Conc}$.

\begin{lemma}
    \label{nfa_conc_aux2}
    Let $x \in Q_1$, $w_1 \in \acc{x}{A_1}$, and $w_2 \in \lang{A_2}$. Then $w_1 w_2 \in \acc{x}{A_{Conc}}$.
\end{lemma}
\begin{proof}
    By induction on $w_1$.
    \begin{enumerate}
        \item For $w_1 = \varepsilon$ we get $x \in F_1$ and thus, by Lemma \ref{nfa_conc_fin1}, the claim follows.
        \item For $w_1 = aw_1'$ we get $(x,a,y) \in \delta_1$ and thus $(x,a,y) \in \delta_{Conc}$. By inductive hypothesis, the claim follows.
    \end{enumerate}
\end{proof}

\code{}{}{automata_nfa_conc_aux2_head}

The next lemma constitutes the other direction. 
Its statement is very general, even though we will only need one of the two cases for the proof of correctness of $A_{Conc}$.
However, with the second case, there is no straight-forward inductive proof.

\begin{lemma}
    \label{nfa_conc_aux1}
    Let $x \in Q_{Conc}$. Let $w \in \acc{x}{A_{Conc}}$. Then, either
    \begin{equation}
        \tag{*}
        \label{nfa_conc_aux11}
        x \in Q_1 \; \wedge \; \exists w_1. \; \exists w_2. \; w = w_1 w_2 \; \wedge \; w_1 \in \acc{x}{A_1} \; \wedge \; w_2 \in \lang{A_2},
    \end{equation}
    or
    \begin{equation}
        \tag{**}
        \label{nfa_conc_aux12}
        x \in Q_2 \; \wedge \; w \in \acc{x}{A_2}.
    \end{equation}
\end{lemma}
\begin{proof}
    By induction on $w$. 
    \begin{enumerate}
        \item For $w = \varepsilon$ we get either $x \in F_1$ and $s_2 \in F_2$ or $x \in F_2$.
            In the first case, we need to prove (\ref{nfa_conc_aux11}), which we do by choosing $w_1 := \varepsilon$ and $w_2 := \varepsilon$.
            In the second case, we need to prove $\varepsilon \in \acc{x}{A_2}$ and thus $x \in F_2$ which we have by assumption.
        \item For $w = aw'$ we get $y$ such that $(x,a,y) \in \delta_{Conc}$ and $w' \in \acc{y}{A_{Conc}}$. 
            We are left with four cases, depending on the origin of $x$ and $y$.
            \begin{enumerate}
                \item For $x,y \in Q_2$ we have $(x,a,y) \in Q_2$ and claim (\ref{nfa_conc_aux12}) follows.
                \item For $x,y \in Q_1$ we prove (\ref{nfa_conc_aux11}). 
                    By inductive hypothesis we get $w_1$ and $w_2$ such that (\ref{nfa_conc_aux11}) holds for $y$.
                \item For $x \in Q_1$ and $y \in Q_2$ the claim follows with $w_1 := \varepsilon$ and $w_2 := aw'$ by inductive hypothesis.
                \item For $x \in Q_2$ and $y \in Q_1$ we have $(x, a, y) \in \delta_{Conc}$, which is a contradiction.
            \end{enumerate}
    \end{enumerate}
\end{proof}

\code{}{}{automata_nfa_conc_aux1_head}

\begin{corollary}
    The language of $A_{Conc}$ is the concatenation of the languages of $A_1$ and $A_2$, i.e. $\lang{A_{Conc}} = \lang{A_1} \cdot \lang{A_2}$.
\end{corollary}
\begin{proof}
    Follows directly from Lemma \ref{nfa_conc_aux2} and Lemma \ref{nfa_conc_aux1}. 
\end{proof}

\code{}{}{automata_nfa_conc_correct_head}


\subsection{Star}
The most common construction for the star automaton works by adding the starting state
to the set of final states and connecting all final states to the starting state by $\varepsilon$-transitions.

Again, our construction differs from this.
First, we construct an automaton that accepts the Kleene closure of the language
of the given automaton, excluding the empty word, which we call \lstinline{nfa_repeat}.
The reason for this is that we can easily construct this automaton much in the same way
we constructed the concatenation automaton.

We duplicate all edges from the starting state and add them to the final states.
The resulting automaton accepts the Kleene closure of the language of the given automaton, but not the empty word.
Since we have already constructed an automaton that accepts the empty word, 
and a disjunction operation on automata, we simply combine those with our newly constructed automaton 
to form the star automaton.

\code{}{}{automata_nfa_star}
\codeblock{}{}{automata_nfa_star_correct_head}


We give a procedure to build an equivalent DFA for every extended regular expression and prove it correct.
Note that the operations are named after the type of arguments they take, 
i.e. \lstinline{nfa_star} takes an NFA but returns a DFA,
whereas \lstinline{nfa_conc} expects \textit{and} returns NFAs. 

\code{}{}{re_fa_re_to_dfa}
\codeblock{}{}{re_fa_re_to_dfa_correct_head}


\section{Deciding Equivalence of Regular Expressions}

 
Based on our procedure to construct an equivalent automaton from a regular expression, we can decide equivalence of regular expressions. Given $r_1$ and $r_2$, we construct equivalent DFAs $A_1$ and $A_2$ as above.
Based on our decision procedure for the equivalence of DFAs, we only need check if $A_1$ and $A_2$ are equivalent.

\begin{theorem} 
    \label{re_equiv_correct}
    Let $r, s$ be regular expressions on $\Sigma$ and $A_1, A_2$ their corresponding, equivalent automata. 
    We then have that
    \begin{equation*}
        \lang{r} = \lang{s} \iff \lang{A_1} = \lang{A_2}.
    \end{equation*}
\end{theorem}
\begin{proof}
    Follows directly from \ref{re_to_dfa} and \ref{dfa_equiv_correct}.
\end{proof}

Thus, equivalence is decidable.

\code{}{}{re_fa_re_equiv}
\codeblock{}{}{re_fa_re_equiv_correct_head}

\section{Finite Automata to Regular Expressions}
We prove that there is an equivalent standard regular expression for every finite automaton.
There are three ways to prove this. 


The first one is a method called ``\textbf{state removal}'' \cite{SignalFlow} (reformulated in \cite{springerlink:10.1007/978-3-540-30500-2}),
which works by sequentially building up regular expressions on the edges between states. 
In every step, one state is removed and its adjacent states' edges are updated to incorporate the missing state into the regular expression.
Finally, only two states remain. The resulting edges can be combined to form a regular expression that recognizes the language of the initial automaton.

The formalization of this method is rather complicated, due to the fact that we need generalized finite automata, i.e., 
finite automata whose edges are labeled by regular expressions. 
Thus, we decided against this method.


The second method is known as ``\textbf{Brzozowski's method}'' \cite{DBLP:journals/jacm/Brzozowski64} and builds upon Brzozowski derivatives of regular expressions.
This method is algebraic in nature and arrives at a regular expression by solving a system of linear equations on regular expressions. 
Every state is assigned an unknown regular expression. 
The intuition of these unknown regular expressions is that they recognize the words accepted in their associated state. 
The system is solved by substitution and Arden's lemma \cite{DBLP:conf/focs/Arden61}.
The regular expressions associated with the starting state recognizes the language of the automaton.

Brzozowskis method requires infrastructure for algebraic equations and term rewriting, 
which we estimated to be a considerable overhead. Thus, we decided against this method.


The third method, which we choose for our development, is due to Kleene \cite{KleeneNets}.
It is known as the ``\textbf{transitive closure method}''.
This method recursively constructs a regular expression that is equivalent to the given automaton.
For the remainder of this chapter, we assume that we are given a DFA $A=(Q,s,F,\delta)$.


The idea of the transitive closure method is that we can give a regular expression to describe the path between any two states $x$ and $y$.
This regular expression accepts every word whose run $\sigma$ on $A$ starting in $x$ ends in $y$.
In fact, we can even give such a regular expression if we limit the set of paths through which the run is allowed to pass. 
We will call this set $X$.
Here, passing through means that the restriction applies only to states that are traversed, 
i.e. not to the beginning or end of the run.


If we take $X$ to be the empty set, we only consider two types of runs.
First, if $x \neq y$, every transition from $x$ to $y$ constitutes one (singleton) word. 
Conversely, if there is a word which does not pass through a state and whose run on $A$ starts in $x$ and ends in $y$, 
it can only be a singleton word consisting of one of the transitions from $x$ to $y$.
Therefore, the corresponding regular expression is the disjunction of all transitions from $x$ to $y$. 
These transitions constitute all possible words that lead from $x$ to $y$ without passing through any state.

If $x = y$, we also have to consider the empty word, since its run on $A$ starts in $x$ and ends in $y$.
Thus, the corresponding regular expression is the disjunction of all transitions from $x$ to $y$ \textit{and} $\varepsilon$.


In the case of a non-empty $X$, we make the following observation. 
If we pick an element $z \in X$, then any run $\sigma$ from $x$ to $y$ either passes through $z$, or does not pass through $z$.
If it does, we can split it into three parts.
\begin{enumerate}[label=(\roman*)]
    \item  \label{R_xz}
        The first part contains the prefix of $\sigma$ which contains all states up to the first occurrence of $z$ that is not the starting state.
    \item  \label{R_zz}
        The second part contains that part of the remainder of $\sigma$ which contains all further occurrences of $z$ with the exception of the last state if that is $z$.
    \item  \label{R_zy}
        The third part contains the remainder.
\end{enumerate}

Parts \ref{R_xz} and \ref{R_zy} can easily be expressed in terms of $X\backslash\{z\}$.
Part \ref{R_zz} can be further decomposed into runs from $z$ to $z$ that do not pass through $z$.
Thus, part \ref{R_zz} can also be expressed in terms of $X\backslash\{z\}$ with the help of the $\ ^*$ operator.

If $\sigma$ does not pass through $z$, it is covered by the regular expression for paths from $x$ to $y$ restricted to $X\backslash\{z\}$.

In order to define $R$ recursively, we need to pick an element $z \in X$ if $X \neq \emptyset$. 
For this purpose, we assume an ordering on $Q$.
We will then pick $z \in X$ such that $z$ is the smallest element in $X$ w.r.t. to this ordering. 

\begin{definition}
    \label{R}
    Let $X \subseteq Q$. Let $x, y \in Q$.
    We define R recursively on $|X|$:
    \begin{equation*}
        R^X_{x,y} := \left\{  
                \begin{array}{ll}
                    \vphantom{ \sum\limits_{ \substack{ a \in \Sigma\\ (x,a,y) \in \delta \\ b \in \Sigma } } }
                    \sum\limits_{
                        \substack{
                            a \in \Sigma\\
                            (x,a,y) \in \delta
                        }
                    } a 
                    & \mbox{if } X = \emptyset \wedge x \neq y; \\
                    \vphantom{ \sum\limits_{ \substack{ a \in \Sigma\\ (x,a,y) \in \delta \\ b \in \Sigma } } }
                    \sum\limits_{
                        \substack{
                            a \in \Sigma\\
                            (x,a,y) \in \delta
                        }
                    } a + \varepsilon 
                    & \mbox{if } X = \emptyset \wedge x = y; \\
                     R^{X\backslash\{z\}}_{x,z} (R^{X\backslash\{z\}}_{z,z})^* R^{X\backslash\{z\}}_{z,y} + R^{X\backslash\{z\}}_{x,y}
                     & \mbox{if } X \neq \emptyset \wedge z \mbox{ minimal in } X.
                \end{array}
            \right.
    \end{equation*}
\end{definition}

The formalization of $R$ is more involved than its mathematical definition. 
We give some auxiliary definitions to keep the definition of $R$ as compact and readable as possible.
\lstinline{nPlus} is $\sum$ on regular expressions.
\lstinline{dfa_step_any} is the list of transitions from $x$ to $y$.
\lstinline{R0} covers the case of $X=\emptyset$.

\code{}{}{transitive_closure_nPlus}
\codeblock{}{}{transitive_closure_dfa_step_any}
\codeblock{}{}{transitive_closure_R0}
\codeblock{}{}{transitive_closure_R}

%Following the intuition given above, we try to express $\lang{A}$ by $R$.
We now express $\lang{A}$ using $R$.
Based on the observation that every accepted word has a run from $s$ to some state $f \in F$, 
we only have to combine the corresponding regular expressions $R^Q_{s,f}$ to form a regular expression for $\lang{A}$.
The goal of this chapter is to prove the following theorem. 

\begin{theorem}
    \label{dfa_to_re} $\lang{A}$ is recognizable by a regular expression, i.e.
    \begin{equation*}
        \lang{\sum\limits_{f \in F} R^Q_{s,f}} = \lang{A}.
    \end{equation*}
\end{theorem}

In order to prove this theorem, we will first define a predicate on words that corresponds to $\lang{R^X_{x,y}}$.
We call this predicate $L^X_{x,y}$ and define it such that it includes those words 
whose runs on $A$ starting in $x$ only pass through states in $X$ and end in $y$.
%This is a direct implementation of the idea behind $R^X_{x,y}$.
%Then, we show that $L^{X \cup \{z\}}$ can be expressed in terms of $L^X$.
%We prove that we can express $\lang{A}$ by $\bigcup_{f\in F} L^Q_{s,f}$.
%Finally, we show that $R^X_{x,y} = L^X_{x,y}$, thus proving Theorem \ref{dfa_to_re}.

\begin{definition}
    Let $w \in \Sigma^*$.
    Let $X \subseteq Q$, and $x,y \in X$.
    Let $\sigma$ be the run of $w$ on $A$ starting in $x$.
    We define $L^X_{x,y}$ such that
    \begin{equation*}
        w \in L^X_{x,y} \iff \sigma_{|\sigma|-1} = y \; \wedge \; \forall i \in [1,|\sigma|-2]. \; \sigma_i \in X.
    \end{equation*}
\end{definition}

The formalization of $L$ requires some infrastructure. 
To check the second condition of $L$, we want to be able to state properties of all but the last items in a run.
We define a function \lstinline{belast} to remove the last element from a sequence. 
Note that, mathematically, runs include the starting state.
In our formaliziation, this is not the case.
Thus, we do not need to remove the first state from a run to retrieve all states the run passes through.

%\code{}{}{transitive_closure_belast}
\code{}{}{transitive_closure_allbutlast}
\codeblock{}{}{transitive_closure_L}

We now prove properties of $L$ that we will need for our proof of Theorem \ref{dfa_to_re}.

\begin{lemma}
    \label{L_monotone}
    L is monotone in $X$, i.e.
    \begin{equation*}
        \forall X \subseteq Q, z \in X, x,y \in Q. \; L^X_{x,y} \subseteq L^{X\cup\{z\}} x y.
    \end{equation*}
\end{lemma}
\begin{proof}
    This follows directly from $X \subset X\cup\{z\}$.
\end{proof}

\code{}{}{transitive_closure_L_monotone_head}

\begin{lemma}
    \label{L_nil}
    The empty word is contained in $L^X_{x,y}$ if and only if $x=y$.
\end{lemma}
\begin{proof}
   This follows immediately from the definition of $L$. 
\end{proof}

\code{}{}{transitive_closure_L_nil_head}

Next, we will prove that words whose run passes through a state $z$ can be split into two words. 
The run of the first word will end in $z$, i.e. not pass through $z$.

\begin{lemma}
    \label{run_split}
    Let $w \in \Sigma^*$. Let $x,z \in Q$. 
    Let $\sigma$ be the run of $w$ on $A$ starting in $x$.
    Let $z \in \sigma_1 \ldots \last{\sigma}$.
    Then there exist $w_1, w_2 \in \Sigma^*$ such that
    \begin{equation*}
        w = w_1 w_2 \; \wedge \; |w_2| < |w| \; \wedge \; z \notin \sigma_1 \ldots \sigma_{|w_1|-1} \; \wedge \; \sigma_{|w_1|} = z.
    \end{equation*}
\end{lemma}
\begin{proof}
    %From $z \in \belast{\sigma}$ we have $|w| > 0$.
    Let $i$ be the first occurrence of $z$ in $\sigma_1 \dots \last{\sigma}$ such that
    $\sigma_i = z$ and $i > 0$.
    Let $w_1 := w_0 \ldots w_{i-1}$ and $w_2 := w_i \ldots \last{w}$.
    The claim follows.
\end{proof}

\code{}{}{transitive_closure_run_split_head}

We will make use of this fact in the next lemma, which splits words in $L^{X}$ into two parts,
the first of which is again in $L^{X}$. 
This will be quintessential later, when we split words in $L^{X}$ into three parts 
that correspond to the recursive definition of $R^X$.

\begin{lemma}
    \label{L_split}
    Let $X \subseteq Q$ and $x,y,z \in Q$.
    Let $w \in L^{X\cup\{z\}}_{x,y}$.
    We have that either    
    \begin{equation*}
        w \in L^{X}_{x,y} 
    \end{equation*}
    or there exist $w_1$ and $w_2$ such that
    \begin{equation*}
        w = w_1 w_2 \; \wedge \; |w_2| < |w| \;
        \wedge \; w_1 \in L^X_{x,z} \; \wedge \; w_2 \in L^{X \cup \{z\}}_{z,y}.
    \end{equation*}
\end{lemma}
\begin{proof}
    We first eliminate the case of $z \in X$, which is solved trivially.
    Let $\sigma$ be the run of $w$ on $A$ starting in $x$.
    We do a case distinction on $z \in \sigma_1 \ldots \last{\sigma}$.
    \begin{enumerate}
        \item For $z \notin \sigma_1 \ldots \last{\sigma}$ we can easily show $w \in L^X_{x,y}$.
        \item 
            For $z \in \sigma_1 \ldots \last{\sigma}$ we use Lemma \ref{run_split} to split $w$ in $w_1$ and $w_2$.
            From $w \in L^{X\cup\{z\}}_{x,y}$ and $\sigma_{|w_1|} = z$ we immediately get $w_2 \in L^{X\cup\{z\}}_{z,y}$.
            We have $z \notin \sigma_1 \ldots \last{\sigma}$.
            We also have that $X = (X \cup \{z\})\backslash\{z\}$ from $z \notin X$.
            Thus, we get $w_1 \in L^{X}_{x,z}$. The remainder of the claim follows directly from Lemma \ref{run_split}.
    \end{enumerate}
\end{proof}

Before we show that $L^X$ respects the defining equation of $R^X$, 
we have to show that we can combine words from $L^{X}_{x,z}$, $(L^{X}_{z,z})^*$, and $L^{X}_{z,y}$ to form a word in $L^{X\cup\{z\}}_{x,y}$.
We prove a general concatenation lemma for $L^X$.

\begin{lemma}
    \label{L_cat}
    Let $X \subseteq Q$, $x,y\in Q$, and $z \in X$. 
    Let $w_1 \in L^X_{x,z}$ and $w_2 \in L^X_{z,x}$.
    Then we have
    \begin{equation*}
        w_1 w_2 \in L^X_{x,y}.
    \end{equation*}
\end{lemma}
\begin{proof}
    By $z \in X$, $w_1 \in L^X_{x,y}$, and $\sigma_{|w_1|} = z$ we get $\sigma_1, \ldots, \sigma_{|w_1|} \in X$.
    We also have $\sigma_{|w_1|+1}, \ldots, \sigma_{|\sigma|-2} \in X$ and $\last{\sigma} = y$. Thus, $w_1 w_2 \in L^X_{x,y}$.
\end{proof}

\code{}{}{transitive_closure_L_cat_head}

\begin{lemma}
    \label{L_flatten}
    Let $n \in \mathbb{N}$. Let $w_0, \ldots, w_{n-1} \in L^{X}_{z,z}$.
    We have that
    \begin{equation*}
        w_0 \ldots w_{n-1} \in L^{X\cup\{z\}}_{z,z}.
    \end{equation*}
\end{lemma}
\begin{proof}
    By induction on $n$.
    \begin{enumerate}
        \item For $n = 0$ we have to prove $\varepsilon \in L^{X\cup\{z\}}_{z,z}$ which holds by Lemma \ref{L_nil}.
        \item For $n = n'+1$ we have $w_0 \ldots w_{n-2} \in L^{X\cup\{z\}}_{z,z}$ by inductive hypothesis.
            We also have $w_0, \ldots, w_{n-1} \in L^{X}_{z,z}$ by assumption, and, thus, $w_{n-1} \in L^{X}_{z,z}$.
            By Lemma \ref{L_cat} we get $w_0 \ldots w_{n-1} \in L^{X\cup\{z\}}_{z,z}$.
    \end{enumerate}
\end{proof}
\code{}{}{transitive_closure_L_flatten_head}

%This lemma is quite involved as it is a combination of many different results.
%There is, however, a very clear intuition behind the strategy to prove it.
%Lemma \ref{L_split} allows us to cut off a non-empty prefix from a word $w \in L^{X}_{x,y}$.
%This prefix is in $L^{X}_{x,z}$. 
%By size induction, the remainder of $w$ can be cut into three parts, 
%one in $L^{X}_{z,z}$, one in $(L^{X}_{z,z})^*$ and one in $L^{X}_{z,y}$. 
%We only have to merge the first two parts to prove this direction of the lemma.

%The other direction is easily solved by Lemma \ref{L_cat}.

Finally, we can show that $L^X$ respects the defining equation of $R^X$.
With all the lemmas we have in place now, this can now be shown with relative ease.


\begin{lemma}
    \label{L_rec}
    Let $X \subseteq Q$, $x,y \in Q$, and $z \in X$.
    We have that 
    \begin{equation*}
        L^{X\cup\{z\}}_{x,y} = L^X_{x,z} (L^X_{z,z})^* L^X_{z,y} + L^X_{x,y}.
    \end{equation*}
\end{lemma}
\begin{proof}
    ``$\Rightarrow$''
    By induction on $|w|$.
    \begin{enumerate}
        \item For $|w| = 0$ we get $w \in L^X_{x,y}$ by Lemma \ref{L_nil}. 
        \item For $|w| > 0$ we get $w_1$ and $w_2$ such that $w = w_1 w_2$, $w_1 \in L^X_{x,z}$ and $w_2 \in L^{X\cup\{z\}}_{z,y}$.
            By inductive hypothesis we get 
            \begin{equation*}
             w_2 \in
               L^X_{z,z} (L^X_{z,z})^* L^X_{z,y} \; \vee \; w_2 \in L^X_{z,y}
            \end{equation*}
            The latter gives us $w \in L^{X\cup\{z\}}_{x,y}$ by Lemma \ref{L_cat}.
            With the former, we have $w_3$, $w_4$, and $w_4$ such that $w_2 = w_3 w_4 w_5$, $w_3 \in L^{X}_{z,z}$,
            $w_4 \in (L^X_{z,z})*$ and $w_5 \in L^X_{z,y}$.
            We merge $w_3$ and $w_4$ such that $w_3 w_4 \in (L^{X}_{z,z})^*$.
            This gives us $w_2  \in (L^{X}_{z,z})^* L^X_{z,y}$.
            Thus, $w_1 w_2 \in L^X_{x,z} (L^X_{z,z})^* L^X_{z,y}$.
        \end{enumerate}

    ``$\Leftarrow$''
    We have $w_1 \in L^X_{x,z}$, $w_2 \in (L^X_{z,z})^*$, and $w_3 \in L^X_{z,y}$.
    By Lemma \ref{L_flatten} we get $w_2 \in L^{X\cup\{z\}}_{z,z}$.
    Thus, $w_1 w_2 w_3 \in L^{X\cup\{z\}}_{x,y}$ by Lemma \ref{L_cat}.
\end{proof}
\code{}{}{transitive_closure_L_rec_head}

All that remains to complete the proof of Lemma \ref{dfa_to_re} is a proof of $L^X_{x,y} = \lang{R^X_{x,y}}$.

\begin{lemma}
    \label{L_R}
    Let $X \subseteq Q$. Let $x,y \in Q$. We have that 
    \begin{equation*}
        L^X_{x,y} = R^X_{x,y}.
    \end{equation*}
\end{lemma}
\begin{proof}
    By induction on $|X|$.
    \begin{enumerate}
        \item For $|X| = 0$, the claim follows immediately from the definitions of $L$ and $R$. 
        \item For $|X| = n+1$ for some $n \in \mathbb{N}$ we get $\exists z \in X$ and thus 
            \begin{equation*}
                R^X_{x,y} = R^{X\backslash\{z\}}_{x,z} (R^{X\backslash\{z\}}_{z,z})^* R^{X\backslash\{z\}}_{z,y} 
                + R^{X\backslash\{z\}}_{x,y}.
            \end{equation*}
            By Lemma \ref{L_rec} we also know that 
            \begin{equation*}
                L^X_{x,y} = L^{X\backslash\{z\}}_{x,z} (L^{X\backslash\{z\}}_{z,z})^* L^{X\backslash\{z\}}_{z,y}
                + L^{X\backslash\{z\}}_{x,y}.
            \end{equation*}
            The claim follows by inductive hypothesis.
    \end{enumerate}
\end{proof}

\code{}{}{transitive_closure_L_R_head}

This concludes the proof of Theorem \ref{dfa_to_re}.

\code{}{}{transitive_closure_dfa_to_re}
\codeblock{}{}{transitive_closure_dfa_to_re_correct_head}

In preparation of the final result of this chapter, we prove that $R$ is a standard regular expression.
\begin{lemma}
    \label{R_standard}
        Let $X \subseteq Q$ and $x,y \in Q$. $R^X_{x,y}$ is a standard regular expression.
    \end{lemma}
\begin{proof}
    All regular expressions used in $R$ are standard.
\end{proof}
\code{}{}{transitive_closure_R_standard_head}


The proof of Theorem \ref{dfa_to_re} was by far the most technically involved proof presented in this thesis. 
The mathematical content is rather straight-forward and intuitive.
However, especially due to the need for the \lstinline{allbutlast} predicate,
the implementation contains a lot of quite general infrastructure.
In fact, a little more than one third of the implementation (200 out of 600 lines) is taken up by \lstinline{allbutlast}.


\subsection{Extended Regular Expressions to Regular Languages}

We can now prove that extended regular expressions are equivalent to regular languages.
We show that $R$ is a standard regular expression, which are a subset of extended regular expression which corresponds
to the definition of regular languages.


\begin{theorem}
    \label{ext_re_to_reg_lang}
    Extended regular expressions and regular languages are equally expressive, i.e.
    for all L, we have $L$ is a regular language if and only if there exists an extended regular expression that recognizes $L$.
\end{theorem}
\begin{proof}
    ``$\Rightarrow$'' Let $L$ be regular. 
    Then, by definition of regular languages, there is an equivalent standard regular expression.

    ``$\Leftarrow$'' Let $r$ be an extended regular expression. 
    By Theorem \ref{re_to_dfa} we have DFA $A$ such that $\lang{A} = \lang{r}$.
    By Theorem \ref{dfa_to_re} we have regular expression $s$ such that $\lang{s} = \lang{A}$.
    By Lemma \ref{R_standard}, $s$ is a standard regular expression.
    Thus, by definition of standard regular expressions, $\lang{r}$ is a regular language.
\end{proof}

\code{}{}{transitive_closure_ext_re_to_std_re}
\codeblock{}{}{transitive_closure_ext_re_to_std_re_standard_head}
\codeblock{}{}{transitive_closure_ext_re_to_std_re_correct_head}

\section*{Remarks}

All in all, our formalization of the results presented in this chapter add up to 1,700 lines of code.
About one half of that is due to the construction of finite automata. 
Although most of these constructions are straight-forward, proving them correct requires a lot of attention to detail.
Additionally, we opted to give a corresponding automaton for every \textit{extended} regular expression, which, 
of course, adds to the expected size of the development.
