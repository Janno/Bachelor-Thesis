
\chapter{Finite Automata}
\label{chap:FA}

Another way of characterizing regular languages are finite automata (FA)\cite{DBLP:books/daglib/0011126}. 
We will show that the languages of finite automata are exactly the regular languages. 
Furthermore, we will also derive a decision procedure for equivalence of regular expressions.

\section{Definition}
A finite automaton consists of
\begin{enumerate}
    \item
        finite set of states $Q$, 
    \item 
        a starting state $s \in Q$, 
    \item 
        a set of final states $F \subseteq Q$ 
    \item 
        and a state-transition relation $\delta$. 
\end{enumerate}

We define a \textbf{run} of a word $w \in \Sigma^*$ on an automaton $A = (Q, s, F, \delta)$ as a sequence of states $\sigma$ such that 
for every two consecutive positions $i,i+1$ in $\sigma$ there is 
$(\sigma_i, w_i, \sigma_{i+1}) \in \delta$.
A word $w$ is \textbf{accepted} by $A$ in state $x$ if and only if there exists a run $\sigma$ of $w$ on $A$ such that $\sigma_0 = x \, \wedge \, \sigma_{\vert\sigma\vert-1} \in F$.
The resulting set of accepted words is denoted by $\acc{x}{A}$.
The \textbf{language} of $A$ is exactly $\acc{s}{A}$ and is denoted $\lang{A}$. 

\subsection{Non-Deterministic Finite Automata}
Finite automata can be \textbf{non-deterministic} (NFA) in the sense that there exist multiple distinct runs for a word. 
This is the case if and only if $\delta$ is not functional.

\code{nfa}{Non-Deterministic Finite Automata}{automata_nfa}
\codeblock{nfa_accept}{}{automata_nfa_accept}
\codeblock{nfa_lang}{}{automata_nfa_lang}


The acceptance criterion given here avoids the matter of runs.
In many cases, this will help us with proofs by in induction on the accepted word.
However, we will need runs in some of the proofs.
Due to the fact that runs are not unique on NFAs, 
we give a predicate that decides if a run on $A$ is valid for a word $w$.
We then show that the acceptance criterion given above corresponds to the mathematical definition in terms of runs.

\code{nfa_run}{}{automata_nfa_run}
\codeblock{nfa_run_accept}{}{automata_nfa_run_accept_head}

\subsection{Deterministic Finite Automata}
For functional $\delta$, we speak of \textbf{deterministic} finite automata (DFA). 
In this case, we write $\delta$ as a function in our \coq\ development. 
%This allows us to define the acceptance criterion in terms of the unique sequence of transitions on the automaton. 

\code{dfa}{Deterministic Finite Automata}{automata_dfa}
\codeblock{dfa_accept'}{}{automata_dfa_accept}
\codeblock{dfa_lang}{}{automata_dfa_lang}


Again, we avoid runs in our formalization of the acceptance criterion in favor of a acceptance criterion that is easier to work with in proofs.
In this case, however, we can give a function that computes the unique run of a word on $A$.
This allows us to give an alternative acceptance criterion that is closer to the mathematical definition.
We also prove that both criteria are equivalent.

\code{dfa_run'}{}{automata_dfa_run'}
\codeblock{dfa_run_accept}{}{automata_dfa_run_accept_head}


%
%We can give simpler formalizations of the acceptance on deterministic and non-deterministic automata.
%These will allow us to hide runs and runs as much as possible and instead work with a simple, inductive, boolean predicate.

%\code{automata_dfa_accept}{}{automata_dfa_accept}

\subsubsection{Equivalence of Automata}
\begin{definition}
    We say that two automata are \textbf{equivalent} if and only if their languages are equal.
\end{definition}

\subsubsection{Equivalence between DFA and NFA}
 
Deterministic and non-deterministic finite automata are equally expressive. 
One direction is trivial since every DFA can be seen as a NFA. 
We prove the other direction using the powerset construction. 
Given NFA $A$, we construct an equivalent DFA $A_{det}$ in the following way:
%The new set of states is the powerset of the given NFA's set of states. 
%The new starting state is the singleton set containing the original starting state. 
%A state is final if and only if it contains an original final state. 
%The transition function on powerset states is defined as follows:

\begin{eqnarray*}
    Q_{det} & := & 2^Q \\ %\{P \; | \; P \subseteq Q\} \\
    {s}_{det} & := & \{ s \} \\
    F_{det} & := & \{ P \; | \; P \in Q_{det} \wedge P \cap F \neq \emptyset \} \\
    \delta_{det} & := & \{ (P,a,\bigcup \limits _{p \in P} \{ q \; | \; q \in Q, (p,a,q) \in \delta \}) \; | \; P \in Q_{det}, a \in \Sigma \}.     \\
    A_{det} &:=&  (Q_{det}, s_{det}, F_{det}, \delta_{det}).
\end{eqnarray*}


The formalization of $A_{det}$ is straight-forward. 
We leave the set of states \lstinline_{set A}_ implicit.

\code{}{}{automata_nfa_to_dfa}

\begin{lemma}
    \label{nfa_to_dfa_complete}
    For all powerset states $X$ and for all states $x$ with $x \in X$ we have that
    \begin{equation*}
        \acc{x}{A} \subseteq \acc{X}{A_{det}}.
    \end{equation*}
\end{lemma}

\begin{proof}
    Let $w \in \acc{x}{A}$. We proof by induction on $w$ that $w \in \acc{X}{A_{det}}$. 
    \begin{itemize}
        \item
            For $w = \varepsilon$ and $\varepsilon \in \acc{x}{A}$ we get $x \in F$ from $\varepsilon \in \acc{x}{A}$. 
            From $x \in X$ we get $X \cap F \neq \emptyset$ and therefore $\varepsilon \in \acc{X}{A_{det}}$.
        \item
            For $w = a w'$ and $a w' \in \acc{x}{A}$ we get $y$ such that $w' \in \acc{y}{A}$ and $(x,a,y) \in \delta$.
            The latter gives us $y \in Y$ where $Y$ is such that $(X, a, Y) \in \delta_{det}$.
            With $y \in Y$ and $w' \in \acc{y}{A}$ we get 
            which gives us $w' \in \acc{Y}{A_{det}}$ by inductive hypothesis.
            With $(X, a, Y) \in \delta_{det}$ we get $a w' \in \acc{X}{A_{det}}$.
    \end{itemize}
\end{proof}


\begin{lemma}
    \label{nfa_to_dfa_sound}
    For all powerset states $X$ and all words $w \in \acc{X}{A_{det}}$ there exists a state $x$ such that 
    \begin{equation*}
        x \in X \wedge
        w \in \acc{x}{A}.
    \end{equation*}
\end{lemma}

\begin{proof}
    By induction on $w$. %that there exists $x$ such that $x \in X \wedge w \in \acc{x}{A}$. 
    \begin{itemize}
        \item
            For $w = \varepsilon$ and $\varepsilon \in \acc{X}{A_{det}}$ we get  $X \cap F \neq \emptyset$.
            Therefore, there exists $x$ such that $x \in X$ and $x \in F$.
            Thus, we have $\varepsilon \in \acc{x}{A}$.
        \item
            For $w = a w'$ and $a w' \in \acc{X}{A_{det}}$ we get $Y$ such that $w' \in \acc{Y}{A_{det}}$ and $(X,a,Y) \in \delta_{det}$.
            From the inductive hypothesis we get $y$ such that $y \in Y$ and $w' \in \acc{y}{A}$.
            From $y \in Y$ and $(X, a, Y) \in \delta_{det}$ we get $x$ such that $x \in X$ and $(x, a, y) \in \delta$.
            Thus, $a w' \in \acc{x}{A}$.
    \end{itemize}
\end{proof}

\begin{theorem}
    The powerset automaton $A_{det}$ accepts the same language as $A$, i.e.
    \begin{equation*}        
        \lang{A} = \lang{A_{det}}.        
    \end{equation*}
\end{theorem}
\begin{proof}
    ``$\subseteq$'' 
    This follows directly from lemma \ref{nfa_to_dfa_complete} with $x = s$ and $X = {s}_{det}$.

    ``$\supseteq$''
    From lemma \ref{nfa_to_dfa_sound} with $X = {s}_{det}$ we get 
    $\acc{s_{det}}{A_{det}} \subseteq \acc{s}{A}$, which proves the claim.
\end{proof}


The formalization of this proof is straight-forward and follows the plan laid out above. 
The corresponding Lemmas are:
\code{powerset_complete}{}{automata_nfa_to_dfa_complete_head}
\codeblock{powerset_sound}{}{automata_nfa_to_dfa_sound_head}
\codeblock{powerset_correct}{}{automata_nfa_to_dfa_correct_head}


\section{Connected Components}
 
Finite automata can have isolated subsets of states that are not reachable from the starting state. 
Removing these states does not change the language.
%can not contribute to the language of the automaton since there are no runs from the starting state to any of those unreachable states.
It will later be useful to have automata that only contain reachable states. 
Therefore, we define a procedure to extract the connected component containing the starting state from a given automaton.

\begin{definition}
    \label{A_c}
    Let $A = (Q, s, F, \delta)$ be a DFA.
    We define $\mathrm{reachable1}$ such that for all x and y, 
    $(x,y) \in \mathrm{reachable1} \iff \exists a, (x,a,y) \in \delta$.
    We define $\mathrm{reachable} := \{y \; | \; (s,y) \in \mathrm{reachable1}^*\}$, 
    where $\mathrm{reachable1}^*$ denotes the transitive closure of $\mathrm{reachable1}$.
    With this, we can define the connected automaton $A_c$:
    \begin{eqnarray*}
        Q_c & := & Q \cap reachable \\
        s_c & := & s \\
        F_c & := & F \cap reachable \\
        \delta_c & := & \{(x, a, y) \; | \; (x, a, y) \in \delta \wedge x,y \in Q_c \} \\
        A_c &:=& (Q_c, s_c, F_c, \delta_c).
    \end{eqnarray*}
\end{definition}


We make use of \ssreflect's $connect$ predicate to extract a sequence of all states reachable from $s$. 
From this, we construct a finite type and use that as the new set of states. 
These new states carry a proof of reachability. %(\lstinline{ssvalP}).
We also have to give a transition function that ensures transitions always end in reachable states.

\code{automata_reachable1}{}{automata_reachable1}
\codeblock{automata_reachable}{}{automata_reachable}
\codeblock{automata_reachable0}{}{automata_reachable0_head}
\codeblock{automata_reachable_step}{}{automata_reachable_step_head}
\codeblock{automata_dfa_connected}{}{automata_dfa_connected}

\todo{Make this understandable}

\begin{lemma}
    \label{dfa_connected_correct'}
    For every state $x \in \mathrm{reachable}$ we have that
    \begin{equation*}
        \acc{x}{A_c} = \acc{x}{A}.
    \end{equation*}
\end{lemma}
\begin{proof}
    ``$\subseteq$'' Trivial.
    ``$\supseteq$''
    We do an induction on $w$.
    \begin{itemize}
        \item
            For $w = \varepsilon$ we have $\varepsilon \in \acc{x}{A}$ and therefore $x \in F$. 
            With $x \in reachable$ we get $x \in F_c$. 
            Thus, $\varepsilon \in \acc{x}{A_c}$.
        \item
            For $w = a w'$ we have have $y \in Q$ such that $(x, a, y) \in \delta$ and $w' \in \acc{y}{A}$.
            From $x \in \mathrm{reachable}$ we get $y \in \mathrm{reachable}$ by transitivity.
            Therefore, $(x,a,y) \in \delta_c$.
            The inductive hypothesis gives us $w' \in \acc{y}{A_c}$. 
            Thus, $a w' \in \acc{x}{A_c}$.
    \end{itemize}
\end{proof}

\begin{theorem}
    \label{dfa_connected_correct}
    The language of the connected automaton $A_c$ is identical to that of the original automaton $A$, i.e.
    \begin{equation*}
        \lang{A} = \lang{A_c}.        
    \end{equation*}
\end{theorem}

\begin{proof}
    By reflexivity, we have $s \in \mathrm{reachable}$. 
    We use lemma \ref{dfa_connected_correct'} with $x = s$ to prove the claim.
        %Unreachable states have no influence on the language of an automaton because there is no run from the starting state that contains such a state.
\end{proof}


The formalization of lemma \ref{dfa_connected_correct'} and theorem \ref{dfa_connected_correct} is straight-forward.

\code{automata_dfa_connected_correct'}{}{automata_dfa_connected_correct'_head}
\codeblock{automata_dfa_connected_correct}{}{automata_dfa_connected_correct_head}


To make use of the fact that $A_c$ is fully connected, we will proof a characteristic property of $A_c$. 
We will need this property of $A_c$ in chapter \ref{chap:MN}.


\begin{definition}
    A \textbf{representative} of a state $x$ is a word $w$ such that the unique run of $w$ on $A_c$ ends in $x$.
\end{definition}

\begin{lemma}
    \label{dfa_connected_repr}
    We can compute give a representative for every state $x \in Q_c$.
    %\todo{Sigma?}
\end{lemma}

\begin{proof}
    $x$ carries a proof of reachability.
    From this, we get a path through the graph of $\mathrm{reachable1}$ that ends ind $x$.
    We build the representative by extracting the edges of the path and building a word from those.
    \todo{Choice?}
\end{proof}


%The formalization of theorem \ref{dfa_connected_repr} includes a more general version of the theorem, 
%which facilitates the proof by induction over the path.

%\code{dfa_connected_repr'}{}{automata_dfa_connected_repr'_head}
\codeblock{}{}{automata_dfa_connected_repr_head}


\section{Emptiness}

Given an automaton $A$, we can check if $\lang{A} = \emptyset$. We simply obtain the connected automaton of $A$ and check if there are any final states left. 

\begin{theorem}
    \label{dfa_lang_empty}
    The language of the connected automaton $A_c$ is empty if and only if its set of final states $F_c$ is empty, i.e.
    \begin{equation*}
        \lang{A} = \emptyset \iff F_c = \emptyset.
    \end{equation*}
\end{theorem}

\begin{proof}
    By theorem \ref{dfa_connected_correct} we have $\lang{A} = \lang{A_c}$.
    Therefore, it suffices to show
    \begin{equation*}
        \lang{A_c} = \emptyset \iff F_c = \emptyset.
    \end{equation*}
    ``$\Leftarrow$''
    We have $\lang{A_c} = \emptyset$ and have to show that for all $x \in Q_c$, $x \notin F_c$.
    Let $x \in Q_c$. 
    By lemma \ref{dfa_connected_repr} we get $w$ such that the unique run of $w$ on $A_c$
    ends in $x$. 
    We use $\lang{A_c} = \emptyset$ to get $w \notin \lang{A_c}$, 
    which implies that the run of $w$ on $A_c$ ends in a non-final state.
    By substituting the last state of the run by $x$ we get $x \notin F_c$.
    ``$\Rightarrow$''
    We have $F_c = \emptyset$ and have to show that for all words $w$, $w \notin \lang{A_c}$.
    We use $F_c = \emptyset$ to show that the last state of the run of $w$ on $A_c$ is non-final.
    Thus, $w \notin \lang{A_c}$.

    Thus, emptiness is decidable.
\end{proof}



%The formalization of lemma \ref{dfa_lang_empty} is split in two parts to facilitate its application. 

\code{}{}{automata_dfa_lang_empty}
%\codeblock{dfa_lang_empty_complete}{}{automata_dfa_lang_empty_complete_head}
%\codeblock{dfa_lang_empty_sound}{}{automata_dfa_lang_empty_sound_head}
\codeblock{dfa_lang_empty_correct}{}{automata_dfa_lang_empty_correct_head}



\section{Deciding Equivalence of Finite Automata}
Given finite automata $A_1$ and $A_2$, we construct DFA $A$ such that the language of $A$ is the symmetric difference of the languages of $A_1$ and $A_2$, i.e.,
\begin{equation*}          
    \lang{A} := \lang{A_1} \ominus \lang{A_2} = \lang{A_1} \cap \neg \lang{A_2} \cup \lang{A_2} \cap \neg \lang{A_1}.      
\end{equation*}
\begin{theorem} The equivalence of $A_1$ and $A_2$ is decidable, i.e.
    \label{dfa_sym_diff_correct}
    \begin{equation*}                
        \lang{A_1} = \lang{A_2} \mbox{ if and only if } \lang{A} \mbox{ is empty. }                
    \end{equation*}
\end{theorem}
\begin{proof}
    The correctness of this procedure follows from the properties of the symmetric difference operator, i.e.
    \begin{equation*}                  
        \lang{A_1} \ominus \lang{A_2} = \emptyset \Leftrightarrow \lang{A_1} = \lang{A_2}.                  
    \end{equation*}
    Thus, equivalence is decidable.    
\end{proof}

\code{}{}{automata_dfa_sym_diff}
\codeblock{}{}{automata_dfa_sym_diff_correct_head}

\section{Regular Expressions and Finite Automata}

 
We prove that there is a finite automaton for every extended regular expression and vice versa. 
In fact, we can give a standard regular expression for every finite automaton.
With this, we will prove that extended regular expressions are equivalent to standard regular expressions, 
thereby proving closure under intersection and negation.


\subsection{Regular Expressions to Finite Automata}

 
We prove that there exists an equivalent automaton for every extended regular expression.
The structure of this proof is given by the inductive nature of regular expressions.
%For every constructor, we provide an equivalent automaton.


Depending on the constructor of the regular expression, we will construct an equivalent DFA or NFA.
\lstinline{Void}, \lstinline{Eps}, \lstinline{Dot}, \lstinline{Atom}, \lstinline{Plus}, \lstinline{And} and \lstinline{Not} are very easy to implement on DFAs, whereas \lstinline{Star} and \lstinline{Conc} lend themselves well to NFAs.

\subsubsection{Void}
\begin{definition}
    We define an empty DFA with a single, non-accepting state, i.e.
    \begin{equation*}
        A_\emptyset := (\{t\}, t, \emptyset, \{(t, a, t) \; | \; a \in \Sigma\}).
    \end{equation*}
\end{definition}

\begin{lemma}
    \label{dfa_empty_correct}
    The language of the empty DFA is empty, i.e.
    \begin{equation*}
        \lang{E} = \emptyset.
    \end{equation*}
\end{lemma}

\begin{proof}
    $A_\emptyset$ has no final states, i.e. no run can end in a final state.
\end{proof}


\code{}{}{automata_dfa_void}
\codeblock{}{}{automata_dfa_void_correct_head}


\subsubsection{Eps}
\begin{definition}
    We define an automaton that accepts only the empty word, i.e.
    \begin{equation*}
        A_\varepsilon := (\{t, f\}, t, \{f\}, \{(x, a, f) \; | \; x \in \{t, f\}, a \in \Sigma\}).
    \end{equation*}
\end{definition}

\begin{lemma}
    \label{dfa_eps_correct'}
    $A_\varepsilon$ accepts no word in state $f$, i.e. for all w,
    \begin{equation*}
        w \notin \acc{f}{A_\varepsilon}.
    \end{equation*}
\end{lemma}
\begin{proof}
    Let $w \in \Sigma^*$.
    We do an induction on $w$. 
    For $w = \varepsilon$ we get $\varepsilon \notin \acc{f}{A_\varepsilon}$ by $f \notin F_\varepsilon$. 
    For $w = aw'$ we have $w' \notin \acc{f}{A_\varepsilon}$. 
    Furthermore, $(f, a, f) \in \delta_\varepsilon$.
    Therefore, $aw' \notin \acc{f}{A_\varepsilon}$.
\end{proof}

\begin{lemma}
    \label{dfa_eps_correct}
    The language of $A_\varepsilon$ is exactly the singleton set containing the empty word, i.e.
    \begin{equation*}
        \lang{A_\varepsilon} = \{\varepsilon\}.
    \end{equation*}
\end{lemma}

\begin{proof}
    Let $w \in \Sigma^*$.
    We do an induction on $w$. 
    For $w = \varepsilon$ we have $\varepsilon \in \lang{A_\varepsilon}$ and $\varepsilon \in \{\varepsilon\}$.
    Therefore, both directions are trivial.
    For $w = aw'$ we consider both directions independently. \\
    ``$\Rightarrow$'' We have $(t, a, f) \in \delta_\varepsilon$ and $w' \in \acc{f}{A_\varepsilon}$. By lemma \ref{dfa_eps_correct'}, this is a contradiction. \\
    ``$\Leftarrow$'' We get a straight-forward contradiction from $aw' \in \{\varepsilon\}$.
\end{proof}

\code{}{}{automata_dfa_eps}
\codeblock{}{}{automata_dfa_eps_correct_head}
\todo{reflect?}


\subsubsection{Dot}
\begin{definition}
    We define an automaton that accepts the set of all singleton words, i.e.
    \begin{equation*}
        A_{Dot} := (\{s, t, f\}, s, \{t\}, 
        \{(s, a, t) \; | \; a \in \Sigma\}
        \; \cup \;
        \{(x, a, f) \; | \; x \in \{t, f\}, a \in \Sigma\}
        ).
    \end{equation*}
\end{definition}

\begin{lemma}
    \label{dfa_dot_correct''}
    $A_{Dot}$ does not accept any word in state $f$, i.e. $\acc{f}{A_{Dot}} = \emptyset$.
\end{lemma}
\begin{proof}
    We prove this by induction on $w \in \Sigma^*$. 
    For $w = \varepsilon$ we have $\varepsilon \notin \acc{f}{A_{Dot}}$ by $f \notin F_{Dot}$.
    For $w = aw'$ we have $(f, a, f) \in \delta_{Dot}$ and $w' \notin \acc{f}{A_{Dot}}$ by inductive hypothesis.
    Thus, $aw' \notin \acc{f}{A_{Dot}}$.
\end{proof}

\begin{lemma}
    \label{dfa_dot_correct'}
    $A_{Dot}$ accepts exactly the empty word in state $t$, i.e. $\acc{t}{A_{Dot}} = \{\varepsilon\}$.
\end{lemma}
\begin{proof}
    Let $w \in \Sigma^*$. 
    We do a case distinction on $w$.
    For $w = \varepsilon$ we have $\varepsilon in \acc{t}{A_{Dot}}$ by $t \in F_{Dot}$. We also have $\varepsilon \in \{\varepsilon\}$.
    For $w = aw'$ we get $(t, a, f) \in \delta_{Dot}$. 
    Since $aw' \notin \{\varepsilon\}$ it suffices to show that 
    $w' \notin \acc{f}{A_{Dot}}$,
    which we have by lemma \ref{dfa_dot_correct''}.
\end{proof}

\code{}{}{automata_dfa_dot}
\codeblock{}{}{automata_dfa_dot_correct''_head}
\codeblock{}{}{automata_dfa_dot_correct'_head}
\codeblock{}{}{automata_dfa_dot_correct_head}
\todo{reflect?}

\subsubsection{Not}
\begin{definition}
    Given DFA $A=(Q,s,F,\delta)$, the complement automaton $A_\neg$ is constructed by switching accepting and non-accepting states, i.e.
    \begin{equation*}
       A_\neg := (Q,s,Q\backslash F,\delta). 
    \end{equation*}
\end{definition}

\begin{lemma}
    \label{dfa_compl_correct'}
    For every state $x \in Q$, we have that $w \in \Sigma^*$ is accepted in $x$ by $A_\neg$ if and only if it is not accepted in $x$ by $A$, i.e. $\acc{x}{A_\neg} = \Sigma^* \backslash \acc{x}{A}$ 
\end{lemma}
\begin{proof}
    We do an induction on $w$.
    For $w = \varepsilon$ we have $\varepsilon \in \acc{x}{A_\neg} \iff \varepsilon \in \acc{x}{A}$ from
    $x \in F \iff x \notin Q\backslash F$.
    For $w = aw'$ we get $(y,a,x) \in \delta$. 
    By inductive hypothesis, $w' \in \acc{x}{A_\neg} \iff w' \notin \acc{x}{A}$
    Thus, $aw' \in \acc{y}{A_\neg} \iff aw' \notin \acc{y}{A}$.
\end{proof}
\begin{lemma}
    $A_\neg$ accepts the complement language of $A$, i.e. $\lang{A_\neg} = \Sigma^* \backslash \lang{A}$.
    \label{dfa_compl_correct}
\end{lemma}
\begin{proof}
    This follows directly from lemma \ref{dfa_compl_correct'} with $x = s$.
\end{proof}

\subsubsection{Plus}
\begin{definition}
    Given DFAs $A_1=(Q_1, s_1, F_1, \delta_1)$ and $A_2=(Q_2, s_2, F_2, \delta_2)$ we construct the disjunction automaton  in the following way:
    \begin{eqnarray*}
        Q_\vee &:=& Q_1 \times Q_2 \\
        s_\vee &:=& (s_1, s_2) \\
        F_\vee &:=& \{(x_1,x_2) \; | \; x_1 \in F_1 \vee x_2 \in F_2\} \\
        \delta_\vee &:=& \{( (x_1, x_2),a,(y_1, y_2)) \; | \; a \in \Sigma, (x_1, a, y_1) \in \delta_1, (x_2, a, y_2) \in \delta_2 \} \\
        A_\vee &:=& (Q_\vee, s_\vee, F_\vee, \delta_\vee).
    \end{eqnarray*}
\end{definition}

\begin{lemma}
    \label{dfa_disj_correct'}
    For every state $(x_1, x_2) \in Q_\vee$, we have that
    \begin{equation*}
        \acc{(x_1, x_2)}{A_\vee} = \acc{x_1}{A_1} \cup \acc{x_2}{A_2}.
    \end{equation*}
\end{lemma}
\begin{proof}
    We do a proof by induction on $w \in \Sigma^*$.
    For $w = \varepsilon$ we have, by definition of $F_\vee$, 
    $%\begin{equation*}
    \varepsilon \in \acc{(x_1, x_2)}{A_\vee} 
    \iff \varepsilon \in \acc{x_1}{A_1} \vee \varepsilon \in \acc{x_2}{A_2}.
    $%\end{equation*} 
    \\
    For $w = aw'$ we get $(x_1, a, y_1) \in \delta_1$ and $(x_2, a, y_2) \in \delta_2$.
    By inductive hypothesis, we also have $w' \in \acc{x_1}{A_1} \vee w' \in \acc{x_2}{A_2}$.
    Thus, we get $aw' \in \acc{y_1}{A_1} \vee aw' \in \acc{x_2}{A_2}$.
\end{proof}

\begin{lemma}
    $\lang{A_\vee} = \lang{A_1} \cup \lang{A_2}$.
    \label{dfa_disj_correct}
\end{lemma}
\begin{proof}
    This follows directly from lemma \ref{dfa_disj_correct'} with $x = (s_1, s_2)$.
\end{proof}


\code{}{}{automata_dfa_disj}
\codeblock{}{}{automata_dfa_disj_correct'_head}
\codeblock{}{}{automata_dfa_disj_correct_head}


\subsubsection{And}
\begin{definition}
    Given DFAs 
    $A_1=(Q_1, s_1, F_1, \delta_1)$ and $A_2=(Q_2, s_2, F_2, \delta_2)$ 
    we construct the conjunction automaton  in the following way:
    \begin{eqnarray*}
        Q_\wedge &:=& Q_1 \times Q_2 \\
        s_\wedge &:=& (s_1, s_2) \\
        F_\wedge &:=& \{(x_1,x_2) \; | \; x_1 \in F_1 \wedge x_2 \in F_2\} \\
        \delta_\wedge &:=& \{( (x_1, x_2),a,(y_1, y_2)) \; | \; a \in \Sigma, (x_1, a, y_1) \in \delta_1, (x_2, a, y_2) \in \delta_2 \} \\
        A_\wedge &:=& (Q_\wedge, s_\wedge, F_\wedge, \delta_\wedge).
    \end{eqnarray*}
\end{definition}

\begin{lemma}
    \label{dfa_conj_correct'}
    For every state $(x_1, x_2) \in Q_\wedge$, we have that
    \begin{equation*}
        \acc{(x_1, x_2)}{A_\wedge} = \acc{x_1}{A_1} \cup \acc{x_2}{A_2}.
    \end{equation*}
\end{lemma}
\begin{proof}
    This proof is very similar to lemma \ref{dfa_disj_correct'}.
    We do a proof by induction on $w \in \Sigma^*$.
    For $w = \varepsilon$ we have, by definition of $F_\wedge$, 
    $%\begin{equation*}
    \varepsilon \in \acc{(x_1, x_2)}{A_\wedge} 
    \iff \varepsilon \in \acc{x_1}{A_1} \wedge \varepsilon \in \acc{x_2}{A_2}.
    $%\end{equation*} 
    \\
    For $w = aw'$ we get $(x_1, a, y_1) \in \delta_1$ and $(x_2, a, y_2) \in \delta_2$.
    By inductive hypothesis, we also have $w' \in \acc{x_1}{A_1} \wedge w' \in \acc{x_2}{A_2}$.
    Thus, we get $aw' \in \acc{y_1}{A_1} \wedge aw' \in \acc{x_2}{A_2}$.
\end{proof}

\begin{lemma}
    $\lang{A_\wedge} = \lang{A_1} \cap \lang{A_2}$.
    \label{dfa_conj_correct}
\end{lemma}
\begin{proof}
    This follows directly from lemma \ref{dfa_conj_correct'} with $x = (s_1, s_2)$.
\end{proof}


\code{}{}{automata_dfa_conj}
\codeblock{}{}{automata_dfa_conj_correct'_head}
\codeblock{}{}{automata_dfa_conj_correct_head}


\subsubsection{Conc}
We do not allow $\varepsilon$-transitions in our automata. 
In order to build the concatenation automaton, we duplicate edges from
the starting state of the second automaton and add them to all final states 
of the first automaton.

\begin{definition}
   Given two NFAs
    $A_1=(Q_1, s_1, F_1, \delta_1)$ and $A_2=(Q_2, s_2, F_2, \delta_2)$ 
    we construct the concatenation automaton in the following way:
    %\begin{eqnarray*}
    \begin{align*}
        Q_{Conc} &:= Q_1 \; \dotcup \; Q_2 \\
        s_{Conc} &:= s_1 \\
        F_{Conc} &:= 
            \begin{cases}
                \begin{array}{ll}
                    F_2 & \mbox{ if } s_2 \notin F_2 \\
                    F_2 \cup F_1 & \mbox{ if } s_2 \in F_2
                \end{array}
            \end{cases}
        \\ %\mathbf{TODO}\\
        \delta_{Conc} &:= \delta_1 \; \cup \; \delta_2 \; \cup \; 
                         \{(x, a, y) \; | \; x \in Q_1, y \in Q_2, (s_2, a, y) \in \delta_2 \} \\
        %\{( (x_1, x_2),a,(y_1, y_2)) \; | \; a \in \Sigma, (x_1, a, y_1) \in \delta_1, (x_2, a, y_2) \in \delta_2 \} \\
        A_{Conc} &:= (Q_{Conc}, s_{Conc}, F_{Conc}, \delta_{Conc}).
    \end{align*}
    %\end{eqnarray*}
\end{definition}

\code{}{}{automata_nfa_conc}

Before we prove the correctness of $A_{Conc}$, we need a number of auxiliary lemmas.

\begin{lemma}
    \label{nfa_conc_cont}
    Every run of $A_2$ can be mapped to a run in $A_{Conc}$.
\end{lemma}
\begin{proof}
    Let $\sigma$ be a run starting in $x$ for $w \in \Sigma^*$ on $A_2$.
    We do an induction on $\sigma$.
    \begin{enumerate}
        \item 
            For $\sigma = x$
            we have $w = \varepsilon$.
            Therefore, we have that $\sigma$ is also a run starting in $x$ for $\varepsilon$ on $A_{Conc}$.
        \item
            For $\sigma = xy\sigma'$ we have $w = aw'$, $(x, a, y) \in \delta_2$.
            By definition of $\delta_{Conc}$ we also have $(x, a, y) \in \delta_{Conc}$.
            By inductive hypothesis, we have that $y\sigma'$ is a run for $w'$ starting in $y$ on $A_{Conc}$.
            Thus, $xy\sigma'$ is a run for $aw'$ starting in $x$ on $A_{Conc}$.
    \end{enumerate}
\end{proof}

\code{}{}{automata_nfa_conc_cont_head}

The next lemma shows that, in $A_{Conc}$, the final states of $A_1$ have all transitions that the starting state of $A_2$ also has.
Consequently, the accept the same words.

\begin{lemma}
    \label{nfa_conc_fin1}
    Let $x \in F_1$. Let $w \in \lang{A_2}$. Then $w \in \acc{x}{A_{Conc}}$.
\end{lemma}
\begin{proof}
    By induction on $w$. 
    \begin{enumerate}
        \item For $w = \varepsilon$ we have get $s \in F_2$ by $\varepsilon \in \lang{A_2}$ and, thus, $x \in F_{Conc}$ by definition.
        \item For $w = aw'$ we have $y \in Q_2$ such that $(s,a,y) \in \delta_2$ and thus $(x,a,y) \in \delta_{Conc}$.
            %By inductive hypothesis we have $w \in \acc{y}{A_{Conc}}$.
            We also have $w' \in \acc{y}{A_2}$ and thus, by lemma \ref{nfa_conc_cont}, $w' \in \acc{y}{A_{Conc}}$.
            Thus, $aw' \in \acc{x}{A_{Conc}}$.
    \end{enumerate}
\end{proof}

\code{}{}{automata_nfa_conc_fin1_head}

The next lemma is one direction of the proof of correctness of $A_{Conc}$.

\begin{lemma}
    \label{nfa_conc_complete}
    Let $x \in Q_1$, $w_1 \in \acc{x}{A_1}$, and $w_2 \in \lang{A_2}$. Then $w_1 w_2 \in \acc{x}{A_{Conc}}$.
\end{lemma}
\begin{proof}
    By induction on $w_1$.
    \begin{enumerate}
        \item For $w_1 = \varepsilon$ we get $x \in F_1$ and thus, by lemma \ref{nfa_conc_fin1}, the claim follows.
        \item For $w_1 = aw_1'$ we get $(x,a,y) \in \delta_1$ and thus $(x,a,y) \in \delta_{Conc}$. By inductive hypothesis, the claim follows.
    \end{enumerate}
\end{proof}

\code{}{}{automata_nfa_conc_complete_head}

The next lemma constitutes the other direction. 
Its statement is very general, even though we will only need one of the two cases for the proof of correctness of $A_{Conc}$.
However, with the second case, there is no straight-forward inductive proof.

\begin{lemma}
    \label{nfa_conc_sound}
    Let $x \in Q_{Conc}$. Let $w \in \acc{x}{A_{Conc}}$. Then, either
    \begin{equation}
        \tag{*}
        \label{nfa_conc_sound1}
        x \in Q_1 \; \wedge \; \exists w_1. \; \exists w_2. \; w = w_1 w_2 \; \wedge \; w_1 \in \acc{x}{A_1} \; \wedge \; w_2 \in \lang{A_2},
    \end{equation}
    or
    \begin{equation}
        \tag{**}
        \label{nfa_conc_sound2}
        x \in Q_2 \; \wedge \; w \in \acc{x}{A_2}.
    \end{equation}
\end{lemma}
\begin{proof}
    By induction on $w$. 
    \begin{enumerate}
        \item For $w = \varepsilon$ we get either $x \in F_1$ and $s_2 \in F_2$ or $x \in F_2$.
            In the first case, we need to prove (\ref{nfa_conc_sound1}), which we do by choosing $w_1 := \varepsilon$ and $w_2 := \varepsilon$.
            In the second case, we need to prove $\varepsilon \in \acc{x}{A_2}$ and thus $x \in F_2$ which we have by assumption.
        \item For $w = aw'$ we get $y$ such that $(x,a,y) \in \delta_{Conc}$ and $w' \in \acc{y}{A_{Conc}}$. 
            We are left with four cases, depending on the origin of $x$ and $y$.
            \begin{enumerate}
                \item For $x,y \in Q_2$ we have $(x,a,y) \in Q_2$ and claim (\ref{nfa_conc_sound2}) follows.
                \item For $x,y \in Q_1$ we prove (\ref{nfa_conc_sound1}). 
                    By inductive hypothesis we get $w_1$ and $w_2$ such that (\ref{nfa_conc_sound1}) holds for $y$.
                \item For $x \in Q_1$ and $y \in Q_2$ the claim follows with $w_1 := \varepsilon$ and $w_2 := aw'$ by inductive hypothesis.
                \item For $x \in Q_2$ and $y \in Q_1$ we have $(x, a, y) \in \delta_{Conc}$, which is a contradiction.
            \end{enumerate}
    \end{enumerate}
\end{proof}

\code{}{}{automata_nfa_conc_sound_head}

\begin{corollary}
    The language of $A_{Conc}$ is the concatenation of the languages of $A_1$ and $A_2$, i.e. $\lang{A_{Conc}} = \lang{A_1} \cdot \lang{A_2}$.
\end{corollary}
\begin{proof}
    Follows directly from lemma \ref{nfa_conc_complete} and lemma \ref{nfa_conc_sound}. 
\end{proof}

\code{}{}{automata_nfa_conc_correct_head}


\subsubsection{Star}





\todo{Include all proofs}

\subsection{Deciding Equivalence of Regular Expressions}

 
Based on our procedure to construct an equivalent automaton from a regular expression, we can decide equivalence of regular expressions. Given $r_1$ and $r_2$, we construct equivalent DFA $A_1$ and $A_2$ as above.


\subsection{Finite Automata to Regular Expressions}
We prove that there is an equivalent standard regular expression for every finite automaton.
There are three ways to prove this. 


The first one is a method called ``\textbf{state removal}'' \cite{SignalFlow} (reformulated in \cite{springerlink:10.1007/978-3-540-30500-2}),
which works by sequentially building up regular expressions on the edges between states. 
In every step, one state is removed and its adjacent states' edges are updated to incorporate the missing state into the regular expression.
Finally, only two states remain. The resulting edges can be combined to form a regular expression that recognizes the language of the initial automaton.


The second method is known as ``\textbf{Brzozowski's method}'' \cite{DBLP:journals/jacm/Brzozowski64} and builds upon Brzozowski derivatives of regular expressions.
This method is algebraic in nature and arrives at a regular expression by solving a system of linear equations on regular expressions. 
Every state is assigned an unknown regular expression. 
The intuition of these unknown regular expressions is that they recognize the words accepted in their associated state. 
The system is solved by substitution and Arden's lemma \cite{DBLP:conf/focs/Arden61}.
The regular expressions associated with the starting state recognizes the language of the automaton.


The third method, which we chose for our development, is due to Kleene \cite{KleeneNets}.
It is known as the ``\textbf{transitive closure method}''.
This method recursively constructs a regular expression that is equivalent to the given automaton.
We now give a detailed 
For the remainder of the chapter, we assume that we are given a DFA $A=(Q,s,F,\delta)$.


The idea of the transitive closure method is that we can give a regular expression to describe the path between any two states $x$ and $y$.
This regular expression accepts every word whose run $\sigma$ on $A$ starts in $x$ ends in $y$.
In fact, we can even give such a regular expression if we limit the set of paths through which the run is allowed to pass. 
We will call this set $X$.
Passing through, here, means that the restriction applies only to states that are traversed, 
i.e. not to the beginning or end of the run.


If we take $X$ to be the empty set, we only consider two types of runs.
First, if $x \neq y$, every transition from $x$ to $y$ constitutes one (singleton) word. 
Conversely, if there is a word which does not pass through a state and whose run on $A$ starts in $x$ and ends in $y$, 
it can only be a singleton word consisting of one of the transitions from $x$ to $y$.
Therefore, the corresponding regular expression is the disjunction of all transitions from $x$ to $y$. 
These transitions constitutes all possible words that lead from $x$ to $y$ without passing through any state.

Otherwise, if $x = y$, we also have to consider the empty word, since its run on $A$ starts in $x$ and ends in $y$.
Thus, the corresponding regular expression is the disjunction of all transitions from $x$ to $y$ \textit{and} $\varepsilon$.


In the case of a non-empty $X$, we make the following observation. 
If we pick an element $z \in X$, then any run $\sigma$ from $x$ to $y$ either passes through $z$, or does not pass through $z$.
If it does, we can split it into three parts.
\begin{enumerate}[label=(\roman*)]
    \item  \label{R_xz}
        The first part contains the prefix of $\sigma$ which contains all states up to the first occurrence of $z$ that is not the starting state.
    \item  \label{R_zz}
        The second part contains that part of the remainder of $\sigma$ which contains all further occurrences of $z$, though not the last state if that is $z$.
    \item  \label{R_zy}
        The third part contains the remainder.
\end{enumerate}

Parts \ref{R_xz} and \ref{R_zy} can easily be expressed in terms of $X\backslash\{z\}$.
Part \ref{R_zz} can be further decomposed into runs from $z$ to $z$ that do not pass through $z$.
Thus, part \ref{R_zz} can also be expressed in terms of $X\backslash\{z\}$ with the help of the $\ ^*$ operator.

If $\sigma$ does not pass through $z$, it is covered by the regular expression for paths from $x$ to $y$ restricted to $X\backslash\{z\}$.


\begin{definition}
    \label{R}
    Let $X \subseteq Q$. Let $x, y \in Q$.
    We define R recursively on \todo{correct?}$|X|$:
    \begin{equation*}
        R^X_{x,y} := \left\{  
                \begin{array}{ll}
                    \vphantom{ \sum\limits_{ \substack{ a \in \Sigma\\ (x,a,y) \in \delta \\ b \in \Sigma } } }
                    \sum\limits_{
                        \substack{
                            a \in \Sigma\\
                            (x,a,y) \in \delta
                        }
                    } a 
                    & \mbox{if } X = \emptyset \wedge x != y; \\
                    \vphantom{ \sum\limits_{ \substack{ a \in \Sigma\\ (x,a,y) \in \delta \\ b \in \Sigma } } }
                    \sum\limits_{
                        \substack{
                            a \in \Sigma\\
                            (x,a,y) \in \delta
                        }
                    } a + \varepsilon 
                    & \mbox{if } X = \emptyset \wedge x = y; \\
                     R^{X\backslash\{z\}}_{x,z} (R^{X\backslash\{z\}}_{z,z})^* R^{X\backslash\{z\}}_{z,y} + R^{X\backslash\{z\}}_{x,y}
                     & \mbox{if } \exists z \in X.
                \end{array}
            \right.
    \end{equation*}
\end{definition}

The formalization of $R$ is more involved than its mathematical definition. 
We give some auxiliary definitions to keep the definition of $R$ as compact and readable as possible.
\lstinline{nPlus} is $\sum$ on regular expressions.
\lstinline{dfa_step_any} is the list of transitions from $x$ to $y$.
\lstinline{R0} covers the case of $X=\emptyset$.

\todo{explain measure}

\code{}{}{transitive_closure_nPlus}
\codeblock{}{}{transitive_closure_dfa_step_any}
\codeblock{}{}{transitive_closure_R0}
\codeblock{}{}{transitive_closure_R}

Following the intuition given above, we try to express $\lang{A}$ by $R$.
Based on the observation that every accepted word has a run from $s$ to some state $f \in F$, 
we only have to combine the corresponding regular expressions $R^Q_{s,f}$ to form a regular expression for $\lang{A}$.
The goal of this chapter is to prove the following theorem. 

\begin{theorem}
    \label{dfa_to_regex} $\lang{A}$ is recognizable by a regular expression, i.e.
    \begin{equation*}
        \lang{\sum\limits_{f \in F} R^Q_{s,f}} = \lang{A}.
    \end{equation*}
\end{theorem}

In order to prove this theorem, we will first define a predicate on words that corresponds to $\lang{R^X_{x,y}}$.
We call this predicate $L^X_{x,y}$ and define it such that it includes those words 
whose runs on $A$ starting in $x$ only pass through states in $X$ and end in $y$.
This is a direct implementation of the idea behind $R^X_{x,y}$.
Then, we show that $L^{X \cup \{z\}}$ can be expressed in terms of $L^X$.
We prove that we can express $\lang{A}$ by $\bigcup_{f\in F} L^Q_{s,f}$.
Finally, we show that $R^X_{x,y} = L^X_{x,y}$, thus proving theorem \ref{dfa_to_regex}.

\begin{definition}
    Let $w \in \Sigma^*$.
    Let $X \subseteq Q$, and $x,y \in X$.
    Let $\sigma$ be the run of $w$ on $A$ starting in $x$.
    We define $L^X_{x,y}$ such that
    \begin{equation*}
        w \in L^X_{x,y} \iff \sigma_{|\sigma|-1} = y \; \wedge \; \forall i \in [1,|\sigma|-2]. \; \sigma_i \in X.
    \end{equation*}
\end{definition}

The formalization of $L$ requires some infrastructure. 
To check the second condition of $L$, we want to be able to state properties of all but the last items in a run.
We define a function \lstinline{belast} to remove the last element from a sequence. 
Note that, mathematically, runs include the starting state.
In our formaliziation, this is not the case.
Thus, we do not need to remove the first state from a run to retrieve all states the run passes through.

\code{}{}{transitive_closure_belast}
\codeblock{}{}{transitive_closure_allbutlast}
\codeblock{}{}{transitive_closure_L}

We now prove properties of $L$ that we will need for our proof of theorem \ref{dfa_to_regex}.

\begin{lemma}
    \label{L_monotone}
    L is monotone \todo{is this word correct?} in $X$, i.e.
    \begin{equation*}
        \forall X \subseteq Q, z \in X, x,y \in Q. \; L^X x y \subseteq L^{X\cup\{z\}} x y.
    \end{equation*}
\end{lemma}
\begin{proof}
    This follows directly from $X \subset X\cup\{z\}$.
\end{proof}

\code{}{}{transitive_closure_L_monotone_head}

\begin{lemma}
    \label{L_nil}
    The empty word is contained in $L^X_{x,y}$ if and only if $x=y$.
\end{lemma}
\begin{proof}
   This follows immediately from the definition of $L$. 
\end{proof}

\code{}{}{transitive_closure_L_nil_head}

Next, we will prove that words whose run passes through a state $z$ can be split into two words. 
The run of the first word will end in $z$, i.e. not pass through $z$.

\begin{lemma}
    \label{run_split}
    Let $w \in \Sigma^*$. Let $x,z \in Q$. 
    Let $\sigma$ be the run of $w$ on $A$ starting in $x$.
    \todo{notation for membership in runs?}
    Let $z \in \sigma_1 \ldots \last{\sigma}$.
    Then there exist $w_1, w_2 \in \Sigma^*$ such that
    \begin{equation*}
        w = w_1 w_2 \; \wedge \; |w_2| < |w| \; \wedge \; z \notin \sigma_1 \ldots \sigma_{|w_1|-1} \; \wedge \; \sigma_{|w_1|} = z.
    \end{equation*}
\end{lemma}
\begin{proof}
    %From $z \in \belast{\sigma}$ we have $|w| > 0$.
    Let $i$ be the first occurrence of $z$ in $\sigma_1 \dots \last{\sigma}$ such that
    $\sigma_i = z$ and $i > 0$.
    Let $w_1 := w_0 \ldots w_{i-1}$ and $w_2 := w_i \ldots \last{w}$.
    The claim follows.
\end{proof}

\code{}{}{transitive_closure_run_split_head}

We will make use of this fact in the next lemma, which splits words in $L^{X}$ into two parts,
the first of which is again in $L^{X}$. 
This will be quintessential later, when we split words in $L^{X}$ into three parts 
that correspond to the recursive definition of $R^X$.

\begin{lemma}
    \label{L_split}
    Let $X \subseteq Q$ and $x,y,z \in Q$.
    Let $w \in L^{X\cup\{z\}}_{x,y}$.
    We have that either    
    \begin{equation*}
        w \in L^{X}_{x,y}, 
    \end{equation*}
    or there exist $w_1$ and $w_2$ such that
    \begin{equation*}
        w = w_1 w_2 \; \wedge \; |w_2| < |w| \;
        \wedge \; w_1 \in L^X_{x,z} \; \wedge \; w_2 \in L^{X \cup \{z\}}_{z,y}.
    \end{equation*}
\end{lemma}
\begin{proof}
    We first eliminate the case of $z \in X$, which is solved trivially.
    Let $\sigma$ be the run of $w$ on $A$ starting in $x$.
    We do a case distinction on $z \in \sigma_1 \ldots \last{\sigma}$.
    \begin{enumerate}
        \item For $z \notin \sigma_1 \ldots \last{\sigma}$ we can easily show $w \in L^X_{x,y}$.
        \item 
            For $z \in \sigma_1 \ldots \last{\sigma}$ we use lemma \ref{run_split} to split $w$ in $w_1$ and $w_2$.
            From $w \in L^{X\cup\{z\}}_{x,y}$ and $\sigma_{|w_1|} = z$ we immediately get $w_2 \in L^{X\cup\{z\}}_{z,y}$.
            We have $z \notin \sigma_1 \ldots \last{\sigma}$.
            We also have that $X = (X \cup \{z\})\backslash\{z\}$ from $z \notin X$.
            Thus, we get $w_1 \in L^{X}_{x,z}$. The remainder of the claim follows directly from lemma \ref{run_split}.
    \end{enumerate}
\end{proof}

Before we show that $L^X$ respects the defining equation of $R^X$, 
we have to show that we can combine words from $L^{X}_{x,z}$, $(L^{X}_{z,z})^*$, and $L^{X}_{z,y}$ to form a word in $L^{X\cup\{z\}}_{x,y}$.
We prove a general concatenation lemma for $L^X$.

\begin{lemma}
    \label{L_cat}
    Let $X \subseteq Q$, $x,y\in Q$, and $z \in X$. 
    Let $w_1 \in L^X_{x,z}$ and $w_2 \in L^X_{z,x}$.
    Then we have
    \begin{equation*}
        w_1 w_2 \in L^X_{x,y}.
    \end{equation*}
\end{lemma}
\begin{proof}
    By $z \in X$, $w_1 \in L^X_{x,y}$, and $\sigma_{|w_1|} = z$ we get $\sigma_1, \ldots, \sigma_{|w_1|} \in X$.
    We also have $\sigma_{|w_1|+1}, \ldots, \sigma_{|\sigma|-2} \in X$ and $\last{\sigma} = y$. Thus, $w_1 w_2 \in L^X_{x,y}$.
\end{proof}

\code{}{}{transitive_closure_L_cat_head}

With this, we can prove that a sequence of $n$ words $w_0, \ldots, w_{n-1} \in L^{X}_{z,z}$ 
forms a word $w = w_1 \ldots w_{n-1}$ with $w \in L^{X\cup\{z\}}_{z,z}$.

\begin{lemma}
    \label{L_flatten}
    Let $n \in \mathbb{N}$. Let $w_0, \ldots, w_{n-1} \in L^{X}_{z,z}$.
    We have that
    \begin{equation*}
        w_0 \ldots w_{n-1} \in L^{X\cup\{z\}}_{z,z}.
    \end{equation*}
\end{lemma}
\begin{proof}
    By induction on $n$.
    \begin{enumerate}
        \item For $n = 0$ we have to prove $\varepsilon \in L^{X\cup\{z\}}_{z,z}$ which holds by lemma \ref{L_nil}.
        \item For $n = n'+1$ we have $w_0 \ldots w_{n-2} \in L^{X\cup\{z\}}_{z,z}$ by inductive hypothesis.
            We also have $w_0, \ldots, w_{n-1} \in L^{X}_{z,z}$ by assumption, and, thus, $w_{n-1} \in L^{X}_{z,z}$.
            By lemma \ref{L_cat} we get $w_0 \ldots w_{n-1} \in L^{X\cup\{z\}}_{z,z}$.
    \end{enumerate}
\end{proof}
\code{}{}{transitive_closure_L_flatten_head}

Finally, we can show that $L^X$ respects the defining equation of $R^X$.
This lemma is quite involved as it is a combination of many different results.
There is, however, a very clear intuition behind the strategy to prove it.
Lemma \ref{L_split} allows us to cut off a non-empty prefix from a word $w \in L^{X}_{x,y}$.
This prefix is in $L^{X}_{x,z}$. 
By size induction, the remainder of $w$ can be cut into three parts, 
one in $L^{X}_{z,z}$, one in $(L^{X}_{z,z})^*$ and one in $L^{X}_{z,y}$. 
We only have to merge the first two parts to prove this direction of the lemma.

The other direction is easily solved by lemma \ref{L_cat}.


\begin{lemma}
    \label{L_rec}
    Let $X \subseteq Q$, $x,y \in Q$, and $z \in X$.
    We have that 
    \begin{equation*}
        L^{X\cup\{z\}}_{x,y} = L^X_{x,z} (L^X_{z,z})^* L^X_{z,y} + L^X_{x,y}.
    \end{equation*}
\end{lemma}
\begin{proof}
    ``$\Rightarrow$''
    By induction on $|w|$.
    \begin{enumerate}
        \item For $|w| = 0$ we get $w \in L^X_{x,y}$ by lemma \ref{L_nil}. 
        \item For $|w| > 0$ we get $w_1$ and $w_2$ such that $w = w_1 w_2$, $w_1 \in L^X_{x,z}$ and $w_2 \in L^{X\cup\{z\}}_{z,y}$.
            By inductive hypothesis we get 
            \begin{equation*}
             w_2 \in
               L^X_{z,z} (L^X_{z,z})^* L^X_{z,y} \; \vee \; w_2 \in L^X_{z,y}
            \end{equation*}
            The latter gives us $w \in L^{X\cup\{z\}}_{x,y}$ by lemma \ref{L_cat}.
            With the former, we have $w_3$, $w_4$, and $w_4$ such that $w_2 = w_3 w_4 w_5$, $w_3 \in L^{X}_{z,z}$,
            $w_4 \in (L^X_{z,z})*$ and $w_5 \in L^X_{z,y}$.
            We merge $w_3$ and $w_4$ such that $w_3 w_4 \in (L^{X}_{z,z})^*$.
            This gives us with $w_2  \in (L^{X}_{z,z})^* L^X_{z,y}$.
            Thus, $w_1 w_2 \in L^X_{x,z} (L^X_{z,z})^* L^X_{z,y}$.
        \end{enumerate}

    ``$\Leftarrow$''
    We have $w_1 \in L^X_{x,z}$, $w_2 \in (L^X_{z,z})^*$, and $w_3 \in L^X_{z,y}$.
    By lemma \ref{L_flatten} we get $w_2 \in L^{X\cup\{z\}}_{z,z}$.
    Thus, $w_1 w_2 w_3 \in L^{X\cup\{z\}}_{x,y}$ by lemma \ref{L_cat}.
\end{proof}
\code{}{}{transitive_closure_L_rec_head}

All that remains to complete the proof of lemma \ref{dfa_to_regex} is a proof of $L^X_{x,y} = \lang{R^X_{x,y}}$.

\begin{lemma}
    \label{L_R}
    Let $X \subseteq Q$. Let $x,y \in Q$. We have that 
    \begin{equation*}
        L^X_{x,y} = R^X_{x,y}.
    \end{equation*}
\end{lemma}
\begin{proof}
    By induction on $|X|$.
    \begin{enumerate}
        \item For $|X| = 0$, the claim follows immediately from the definitions of $L$ and $R$. 
        \item For $|X| = n+1$ for some $n \in \mathbb{N}$ we get $\exists z \in X$ and thus 
            \begin{equation*}
                R^X_{x,y} = R^{X\backslash\{z\}}_{x,z} (R^{X\backslash\{z\}}_{z,z})^* R^{X\backslash\{z\}}_{z,y} 
                + R^{X\backslash\{z\}}_{x,y}.
            \end{equation*}
            By lemma \ref{L_rec} we also know that 
            \begin{equation*}
                L^X_{x,y} = L^{X\backslash\{z\}}_{x,z} (L^{X\backslash\{z\}}_{z,z})^* L^{X\backslash\{z\}}_{z,y}
                + L^{X\backslash\{z\}}_{x,y}.
            \end{equation*}
            The claim follows by inductive hypothesis.
    \end{enumerate}
\end{proof}

\code{}{}{transitive_closure_L_R_head}

This concludes the proof of theorem \ref{dfa_to_regex}.

\code{}{}{transitive_closure_dfa_to_regex_head}
