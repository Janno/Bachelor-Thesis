\chapter{\coq\ and \ssreflect}
\label{chap:coq}


We decided to employ the Small Scale Reflection Extension (\textbf{\ssreflect}%
\footnote{\url{http://www.msr-inria.inria.fr/Projects/math-components}})
for the \textbf{\coq}%
\footnote{\url{http://coq.inria.fr/}}
proof assistant. 
The most important factors in this decision were \ssreflect's excellent support for finite types, list operations and graphs. \ssreflect{} also introduces an alternative scripting language that can often be used to shorten the bookkeeping overhead of proofs considerably.

\section{\coq}

The Coq system is designed to develop mathematical proofs, and especially to write formal specifications, programs and to verify that programs are correct with respect to their specification. 
It provides a specification language named Gallina. 
Terms of Gallina can represent programs as well as properties of these programs and proofs of these properties. 
Using the so-called Curry-Howard isomorphism, programs, properties and proofs are formalized in the same language called Calculus of Inductive Constructions, that is a $\lambda$-calculus with a rich type system. 
All logical judgments in Coq are typing judgments. 
The very heart of the Coq system is the type-checking algorithm that checks the correctness of proofs, i.e that a program complies to its specification. 
Coq also provides an interactive proof assistant to build proofs using specific programs called tactics \cite{Coq:manual}.



\subsection{Non-structurally Recursive Functions}
\coq\ allows us to define functions that do not recurse in a structural manner.
We make use of \coq's \lstinline{Function} syntax to define functions whose termination is proven by 
showing that a specified measure decreases in every recursive call.
In our case, we will use the size of a finite set as the decreasing measure.
When defining such a recursive functions, we have to prove that every recursive call reduces the size of the finite set.


\section{\ssreflect}


\ssreflect\ is a set of extensions to the proof scripting language of the \coq\ proof assistant. 
They were originally developed to support small-scale reflection. 
However, most of them are of quite general nature and improve the functionality of \coq\ in most basic areas such as script layout and structuring, proof context management and rewriting \cite{gonthier:inria-00258384}.


\subsection{Finite Types} %and Ordinals

The most important feature of \ssreflect\ for our purpose are finite types.  
Finite types are types that have a finite number of inhabitants.
Their implementation is based on lists.
The type of finite types is \lstinline{finType}.
Every element of a finite type is contained in the associated (de-duplicated) list and vice versa.
\ssreflect's support for finite types is based on canonical structures, instances of which come predefined for basic types and type constructors. 
This allows us to easily combine basic finite types such as \lstinline{bool} with type constructors such as \lstinline{option} and \lstinline{sum}. 

\ssreflect\ provides boolean versions of the universal and existential quantifiers on finite types, \lstinline{forallb} and \lstinline{existsb}.
We can compute the number of elements in a finite type F with \lstinline{#|F|}.
\lstinline{enum} gives a list of all items of a finite type. 

We can also create finite types from lists.
Instances of these can be specified with the \lstinline{SeqSub} constructor, 
which takes as arguments an element of the list and a proof that this element is contained in the list.

%Finite types also come with enumeration functions which provide a consistent ordering. 
%The corresponding functions are \lstinline{enum_rank} and \lstinline{enum_val}. 
%The input of \lstinline{enum_val} and the result of \lstinline{enum_rank} are ordinals, i.e. values in \lstinline{[0, \#|F|-1]}. 
%The corresponding type can be written as \lstinline{I_#|F|}

\subsection{Finite Sets}
\ssreflect\ also supports finite sets, which are sets on finite types.
Finite sets themselves are finite types, which enables us to use them in the construction of finite automata.
The type of a finite set is \lstinline!{set T}!, where \lstinline{T} is a finite type.
The function \lstinline{set1} constructs a singleton set containing its first argument. 
The type of the resulting finite set can be inferred from the argument. 
The union over finite sets can be expressed by \lstinline{\bigcup_(x | P x) F}, 
which corresponds to the mathematical notation $\bigcup_{x \in X, P x} F$, with $X$ being the (finite) type of $x$.


\subsection{Boolean Reflection}
\ssreflect\ offers boolean reflections for decidable propositions. 
This allows us to switch back and forth between equivalent boolean and propositional predicates.

\subsection{Boolean Predicates}
\ssreflect\ has special type for boolean predicates, \lstinline{pred T := T -> bool}, where \lstinline{T} is a type.
We make use of \ssreflect's syntax to specify boolean predicates.
This allows us to specify predicates in a way that resembles set-theoretic notation, e.g. 
\lstinline{[pred x | <boolean expression in x> ]}.
Furthermore, we can use the functions \lstinline{pred1} and \lstinline{pred0} to specify the singleton predicate and the empty predicate, respectively.
The complement of a predicate can be written as \lstinline{[predC p]}. 
The syntax for combining predicates is \lstinline{[pred? p1 & p2 ]}, with \lstinline{?} being one of 
\lstinline{U} (union), \lstinline{I} (intersection) or \lstinline{D} (difference).
For predicates given in such a way, we write \lstinline{y \in p} to express that \lstinline{y} fulfills \lstinline{p}.
There is also syntax for the preimage of a predicate under a function
which can be written as \lstinline{[preim f of p]}.

%The resulting predicates are called collective predicates. 
%\ssreflect\ allows us to use infix notation, i.e. $x \in p$, for these predicates.


There are also applicative (functional) versions of of \lstinline{predC}, \lstinline{predU}, \lstinline{predI}, \lstinline{predD}, 
which are functions that take predicates as arguments and return predicates.

\subsection{Equality}
We can use \lstinline{f =1 g} to express that the functions \lstinline{f} and \lstinline{g} agree in all arguments.
If we regard \lstinline{f} and \lstinline{g} as sets, we can write \lstinline{f =i g}, which is defined as \lstinline{forall x, x \in f = x \in g}.
\coq's equality \lstinline{=} is intensional, which means that even if we have \lstinline{f =1 g}, we will not, in general, be able to proof \lstinline{f = g}.
Thus, we will use \lstinline{=1} or \lstinline{=i} in \coq, when we write $=$ mathematically. 
This expresses the notion of extensional equality that is usually assumed mathematically.



