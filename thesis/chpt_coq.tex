\chapter{\coq\ and \ssreflect}
\label{chap:coq}


We decided to employ the Small Scale Reflection Extension (\textbf{\ssreflect}%
\footnote{http://www.msr-inria.inria.fr/Projects/math-components})
for the \textbf{\coq}%
\footnote{http://coq.inria.fr/}
proof assistant. 
The most important factors in this decision were \ssreflect's excellent support for finite types, list operations and graphs. \ssreflect{} also introduces an alternative scripting language that can often be used to shorten the bookkeeping overhead of proofs considerably.

\section{\coq}

The Coq system is designed to develop mathematical proofs, and especially to write formal specifications, programs and to verify that programs are correct with respect to their specification. 
It provides a specification language named Gallina. 
Terms of Gallina can represent programs as well as properties of these programs and proofs of these properties. 
Using the so-called Curry-Howard isomorphism, programs, properties and proofs are formalized in the same language called Calculus of Inductive Constructions, that is a $\lambda$-calculus with a rich type system. 
All logical judgments in Coq are typing judgments. 
The very heart of the Coq system is the type-checking algorithm that checks the correctness of proofs, in other words that checks that a program complies to its specification. 
Coq also provides an interactive proof assistant to build proofs using specific programs called tactics \cite{Coq:manual}.


\todo{Description, citation}

\section{\ssreflect}


\ssreflect\ is a set of extensions to the proof scripting language of the \coq\ proof assistant. 
They were originally developed to support small-scale reflection. 
However, most of them are of quite general nature and improve the functionality of \coq\ in most basic areas such as script layout and structuring, proof context management and rewriting \cite{gonthier:inria-00258384}.


\subsection{Finite Types} %and Ordinals

The most important feature of \ssreflect\ for our purpose are finite types. 
Finite types are types that have a finite number of inhabitants.
Their implementation is based on lists.
Every element of a finite type is contained in the associated (de-duplicated) list and vice versa.
\ssreflect's support for finite types is based on canonical structures, instances of which come predefined for basic finite types and type constructors. 
This allows us to easily combine basic finite types such as \lstinline{bool} with type constructors such as \lstinline{option} and \lstinline{sum}. 

\ssreflect\ provides boolean versions of the universal and existential quantifiers on finite types, \lstinline{forallb} and \lstinline{existsb}.
We can compute the number of elements in a finite type F with \lstinline{#|F|}.
\lstinline{enum} gives a list of all items of a finite type. 

We can also create finite types from lists.
Instances of these finite types can be specified with the \lstinline{SeqSub} constructor, 
which takes as argument an element of the list and a proof that this element is contained in the list.

%Finite types also come with enumeration functions which provide a consistent ordering. 
%The corresponding functions are \lstinline{enum_rank} and \lstinline{enum_val}. 
%The input of \lstinline{enum_val} and the result of \lstinline{enum_rank} are ordinals, i.e. values in \lstinline{[0, \#|F|-1]}. 
%The corresponding type can be written as \lstinline{I_#|F|}

\subsection{Boolean Reflection}
\ssreflect\ offers boolean reflections for decidable propositions. 
This allows us to switch back and forth between equivalent boolean and propositional predicates.

\subsection{Boolean Predicates}
\ssreflect\ has special type for boolean predicates, \lstinline{pred T := T -> bool}, where \lstinline{T} is a type.
We make use of \ssreflect's syntax to specify boolean predicates.
This allows us to specify predicates in a way that resembles set-theoretic notation, e.g. 
\lstinline{[pred x | <boolean expression in x> ]}.
Furthermore, we can use the functions \lstinline{pred1} and \lstinline{pred0} to specify the singleton predicate and the empty predicate, respectively.
The complement of a predicate can be written as \lstinline{[predC p]}. 
The syntax for combining predicates is \lstinline{[pred? p1 & p2 ]}, with \lstinline{?} being one of 
\lstinline{U} (union), \lstinline{I} (intersection) or \lstinline{D} (difference).
For predicates given in such a way, we write \lstinline{y \in p} to express that \lstinline{y} fulfills \lstinline{p}.
There is also syntax for the preimage of a predicate under a function
which can be written as \lstinline{[preim f of p]}.

%The resulting predicates are called collective predicates. 
%\ssreflect\ allows us to use infix notation, i.e. $x \in p$, for these predicates.


There are also applicative (functional) versions of of \lstinline{predC}, \lstinline{predU}, \lstinline{predI}, \lstinline{predD}, 
which are functions that take predicates as arguments and return predicates.

\subsection{Miscellaneous}
We can use \lstinline{f =1 g} to express that the functions \lstinline{f} and \lstinline{g} agree in all arguments.
If we regard \lstinline{f} and \lstinline{g} as sets, we can write \lstinline{f =i g}, which is defined as \lstinline{forall x, x \in f = x \in g}.
\coq's equality \lstinline{=} is intensional, which means that even if we have \lstinline{f =1 g}, we will not, in general, be able to proof \lstinline{f = g}.
Thus, we will use \lstinline{=1} and \lstinline{=i} in \coq, when we write $=$ mathematically. 



