\documentclass{beamer}

\usetheme{Luebeck}
\usecolortheme{dove}

\usepackage{tikz}
\usetikzlibrary{arrows,automata} 

\usepackage{amsmath}
\DeclareMathOperator*{\bigplus}{\mbox{\huge +}}

\begin{document}
\title{Constructive Formalization of Regular Languages}  
\author[Jan-Oliver Kaiser]{Jan-Oliver Kaiser \\{\small Advisors: Christian Doczkal, Gert Smolka }\\{\small Supervisor: Gert Smolka}}

\date{\today} 


\begin{frame}
    \titlepage
\end{frame}

\begin{frame}
    \tableofcontents
\end{frame}

\section{Goal}
\subsection{Current Goal}
\begin{frame}

    \textbf{Goal:}

    Find simple proofs for the decidability of regular expression equivalence and the Myhill-Nerode theorem.
    

\end{frame}

\subsection*{Roadmap}
\begin{frame}
    Roadmap:

    \begin{enumerate}
        \item RE $\Rightarrow$ FA (\textbf{DONE})
        \item Emptiness test on FA (\textbf{Easy})
        \item RE equivalence (\textbf{Follows from 1 and 2})
        \item FA $\Rightarrow$ RE (\textbf{Work in progress})
        \item Myhill-Nerode
    \end{enumerate}

\end{frame}

\section*{Recap}
\begin{frame}
    \textbf{Definitions:} \\
    
    \begin{itemize}
        \item 
            We use extended regular Expressions (RE):
            \[    
            r, s ::= \emptyset \, | \, \varepsilon \, | \,  a \, | \, rs \, | \,  r \,  + \, s \, | \, r \, \& \, s \, |\, r^* \, | \, \neg r
            \]
            \[
                \mbox{\textbf{Def.:} }  \bigplus_{x \in X} r_x := r_{x_0} + ... + r_{x_1}
            \]

        \item 
            Our Finite Automata (FA) are
            \[
                (\Sigma, Q, q_0, F, \delta)
            \]
        (The transition relation $\delta$ of deterministic FA is total).
    \end{itemize}
\end{frame}

\section*{Finite automata to regular expressions}
\subsection*{Difficulty}
\begin{frame}

    \large{\textbf{Finite automata to regular expressions}}

    \begin{itemize}
        \item
            Converting REs to FAs is straight-forward and there is really only one algorithm (with slight variations): \\
            We mirror the constructors of RE in operations on FAs.

            \pause

        \item
            Converting FAs to REs is complicated and there are at least three algorithms found in textbooks.
    \end{itemize}

    \pause

    \textbf{Why is that?}

\end{frame}

\begin{frame}
    \textbf{My intuition:} 
    \begin{itemize}
        \item
            Converting REs to FAs is done by structural recursion on a \textbf{tree}. The result is a \textbf{flat structure}.

            \pause

        \item
            Converting FAs to REs \textbf{can not be done} by structural recursion.
            There is \textbf{no recursive structure} in FAs. \\
            But somehow we need to construct a \textbf{tree} of REs.
    \end{itemize}



\end{frame}

\subsection*{Overview}
\begin{frame}

    \textbf{Three methods (+ variations):}

    \begin{enumerate}
        \item Transitive Closure
        \item State Removal
        \item Brzozowski Algebraic Method
    \end{enumerate}

\end{frame}

\section{Transitive Closure}
\subsection*{Approach}
\begin{frame}

    \large{\textbf{Transitive Closure}} \\

    \textbf{Given}: DFA $A$ = $(\Sigma, Q, q_0, F, \delta)$.

    \textbf{Idea}: Construct regexps $r_f$ for every final states $f \in F$ s.t. \\$r_f$ matches all words which A accepts with final state $f$. \\

    \[
        \, \Rightarrow \mathcal{L}(A) = \mathcal{L}(\bigplus\limits_{f \in F} r_f)
    \]

    \vspace{5 mm}

    \textbf{How do we construct $r_f$?} 

\end{frame}

\subsection*{Algorithm}
\begin{frame}

    We generalize the idea of $r_f$ to $R^k_{i j}$ which matches all words with which lead from state $i$ to $j$ while passing only through states with index smaller than $k$.

    \begin{enumerate}
        \item 
            Merge multiple edges between states to one unified edge.
        \item
            Construct regexp $R^k_{i j}$ recursively:

            \begin{description}

                \item[$R^0_{i j}$]
                    $ := \begin{cases} 
                        r & \mbox{if } i \neq j \wedge i \mbox{ has edge } r \mbox{ to j}  \\
          \varepsilon + r & \mbox{if } i = j \wedge i \mbox{ has edge } r \mbox{ to j}  \\
                \emptyset & \mbox{otherwise}
                    \end{cases}
                    $ 

                \item[$R^k_{i j}$]
                    $ := R^{k-1}_{i k} R^{k-1}_{k k} R^{k-1}_{k j} + R^{k-1}_{i j}$

            \end{description}

    \end{enumerate}

    \[ 
    \Rightarrow \mathcal{L}(A) = \mathcal{L}(\bigplus_{f \in F} r_f) = \mathcal{L}(\bigplus_{f \in F} R^{|Q|}_{0 f}) 
    \]

\end{frame}

\subsection*{Properties}
\begin{frame}
    \begin{description}
        \item[\textbf{Formalization}:] \hfill \\
            Easier than the other methods.\\
            The recursive definition translates quite well.\\
            Some details are quite challenging.

        \item[\textbf{Efficiency}:] The resulting regular expressions are huge.

        \item[\textbf{Complexity}:]
            $O(n^3)$ in the number of states.
    \end{description}
\end{frame}

\section{State Removal}
\subsection*{Approach}
\begin{frame}
    \textbf{State Removal}    

    \textbf{Given}: FA $A$ = $(\Sigma, Q, q_0, F, \delta)$.

    \textbf{New concept}: Automata that have transitions labeled by RE.

    \textbf{Idea}: Remove states until there are two or less states remaining. Update the remaining states' transitions by incorporating the "lost" paths.


\end{frame}

\subsection*{Algorithm}
\begin{frame}
    \textbf{Remove $q$ from}\\

    \begin{figure}
        \begin{tikzpicture}[shorten >=1pt,node distance=2cm,>=stealth,thick]
            \node[state] (1) {$q_i$};
            \node[state] (2) [right of=1] {$q$};
            \node[state] (3) [right of=2] {$q_k$};
            \draw [->] (1) to[bend left] node[auto] {$a$} (2);
            \draw [->] (2) to[bend left] node[auto] {$b$} (3);
            \draw [->] (2) to[loop above] node[auto] {$e$} (2);
            \draw [->] (3) to[bend left] node[auto] {$c$} (2);
            \draw [->] (2) to[bend left] node[auto] {$d$} (1);
        \end{tikzpicture}
        \\
    \end{figure}

    \pause

    \textbf{to get}\\

    \begin{figure}
        \begin{tikzpicture}[shorten >=1pt,node distance=2cm,>=stealth,thick]
            \node[state] (1) {$q_i$};
            \node[state] (3) [right of=2] {$q_k$};
            \draw [->] (1) to[bend left] node[auto] {$ae^*b$} (3);
            \draw [->] (1) to[loop above] node[auto] {$ae^*d$} (1);
            \draw [->] (3) to[bend left] node[auto] {$ce^*d$} (1);
            \draw [->] (3) to[loop above] node[auto] {$ce^*b$} (3);
        \end{tikzpicture}
        \\
    \end{figure}

\end{frame}

\begin{frame}
    \textbf{Repeat until $A$ is of this form:}

    \begin{figure}
        \begin{tikzpicture}[shorten >=1pt,node distance=2cm,>=stealth,thick]
            \node[state] (1) {$q_1$};
            \node[state] (3) [right of=2, accepting] {$q_f$};
            \draw [->] (1) to[bend left] node[auto] {$r_2$} (3);
            \draw [->] (1) to[loop above] node[auto] {$r_1$} (1);
            \draw [->] (3) to[bend left] node[auto] {$r_3$} (1);
            \draw [->] (3) to[loop above] node[auto] {$r_4$} (3);
        \end{tikzpicture}
        \\
        $\Rightarrow \mathcal{L}(A) = \mathcal{L}(r_1^* r_2 (r_4 + r_3 r_1^* r_2)^*)$
    \end{figure}


\end{frame}

\subsection*{Caveats}
\begin{frame}
    \textbf{Caveats} \\
    \begin{itemize}
        \item
            It looks like we only need to update two edges. \\
            \pause
            In reality, there can be $|Q|-1$ states connected to $q$.
            \pause

            \begin{figure}
                \begin{tikzpicture}[shorten >=1pt,node distance=1.5cm,>=stealth,thick,minimum size=1cm]
                    \node[state] (q11) {};
                    \node[state] (q12) [right of = q11] {};
                    \node[state] (q13) [right of = q12] {};
                    \node[state] (q21) [below of = q11] {};
                    \node[state] (q22) [right of = q21] {$q$};
                    \node[state] (q23) [right of = q22] {};
                    \node[state] (q31) [below of = q21] {};
                    \node[state] (q32) [right of = q31] {};
                    \node[state] (q33) [right of = q32] {};

                    \draw [->] (q11) to[bend left=12.5] node[auto] {} (q22);
                    \draw [->] (q22) to[bend left=12.5] node[auto] {} (q11);

                    \draw [->] (q12) to[bend left=12.5] node[auto] {} (q22);
                    \draw [->] (q22) to[bend left=12.5] node[auto] {} (q12);

                    \draw [->] (q13) to[bend left=12.5] node[auto] {} (q22);
                    \draw [->] (q22) to[bend left=12.5] node[auto] {} (q13);

                    \draw [->] (q21) to[bend left=12.5] node[auto] {} (q22);
                    \draw [->] (q22) to[bend left=12.5] node[auto] {} (q21);

                    \draw [->] (q22) to[bend left=12.5] node[auto] {} (q22);
                    \draw [->] (q22) to[bend left=12.5] node[auto] {} (q22);

                    \draw [->] (q23) to[bend left=12.5] node[auto] {} (q22);
                    \draw [->] (q22) to[bend left=12.5] node[auto] {} (q23);

                    \draw [->] (q31) to[bend left=12.5] node[auto] {} (q22);
                    \draw [->] (q22) to[bend left=12.5] node[auto] {} (q31);

                    \draw [->] (q32) to[bend left=12.5] node[auto] {} (q22);
                    \draw [->] (q22) to[bend left=12.5] node[auto] {} (q32);

                    \draw [->] (q33) to[bend left=12.5] node[auto] {} (q22);
                    \draw [->] (q22) to[bend left=12.5] node[auto] {} (q33);


                \end{tikzpicture}
            \end{figure}
    

    \end{itemize}
\end{frame}

\begin{frame}
    \textbf{Caveats} \\
    \begin{itemize}
        \item
            It looks like we only need to update two edges. \\
            In reality, there can be $|Q|-1$ states connected to $q$.
        \item
            What about final states?\\
            \pause
            Introduce a new final state without any outgoing edges. \\
            Introduce $\varepsilon$ transitions from all other final states to the final new state. \\
            Make all other states non-final. \\
            Never remove the new final state.
    \end{itemize}
\end{frame}

\subsection*{Properties}
\begin{frame}
    \begin{description}
        \item[\textbf{Formalization}:] \hfill \\
            Complex.\\
            Lots of details to consider.
        \item[\textbf{Efficiency}:] 
            The resulting regular expressions are big.\\
            They can be made small in special cases (e.g., acyclic automata).

        \item[\textbf{Complexity}:]
            $O(n^3)$ in the number of states.\\
            Less in special cases (e.g. $O(n^2 log n)$ for acyclic automata).
    \end{description}
\end{frame}

\section{Brzozowski Algebraic Method}
\subsection*{Approach}
\begin{frame}
    \textbf{Brzozowski Algebraic Method}

    \textbf{Given}: FA $A$ = $(\Sigma, Q, q_0, F, \delta)$.\\
    \textbf{Idea}: Retrieve a RE for FA by solving a system of equations determined by $\delta$.

\end{frame}

\subsection*{Algorithm}
\begin{frame}
    \textbf{Construct system of equations}:

    \begin{equation*}
        \begin{array}{lcll} 
            r_0 & = & 
            \displaystyle\sum\limits_{
                \substack{a \in \Sigma \\ 0 \leq i < |Q|} 
            }
            \{ \, a \, r_i \, |  \, (q_0, a, q_i) \in \delta \} 
            &
            (+ \, \varepsilon \mbox{ if } r_0 \in F)
            \\ 
           \vdots &  = & \vdots \\
        r_{|Q|-1} & = & 
            \displaystyle\sum\limits_{
                \substack{a \in \Sigma \\ 0 \leq i < |Q|} 
            }
            \{ \, a \, r_i \, |  \, (q_{|Q|-1}, a, q_i) \in \delta \} 
            &
            (+ \, \varepsilon \mbox{ if } r_{|Q|-1} \in F)
            \\ 
        \end{array}
    \end{equation*}
    $\, \Rightarrow \mathcal{L}(A) = \mathcal{L}(r_0)$
\end{frame}

\begin{frame}
    Solve the system by substitution and \textbf{Arden's Lemma} which states that for all regular languages X, Y and Z the equation
    \begin{equation}
        \begin{array}{lcl}
            X = YX + Z
        \end{array}
    \end{equation}

    has the unique solution

    \begin{equation}
        \begin{array}{lcl}
            X = Y^*Z
        \end{array}
    \end{equation}
\end{frame}

\subsection*{Properties}
\begin{frame}
    \begin{description}
        \item[\textbf{Formalization}:] \hfill \\
            Complex due to missing infrastructure.\\
        \item[\textbf{Efficiency}:] 
            The resulting regular expressions are quite small.\\

        \item[\textbf{Complexity}:]
            $O(n^3)$ in the number of states.\\
            Less in special cases (e.g. $O(n^2 log n)$ for acyclic automata).
    \end{description}
\end{frame}

\section{Our Approach}
\begin{frame}
    \begin{itemize}
        \item
           We eliminated the Brzozowski algebraic method due to its heavy overhead in required infrastructure.

        \pause

        \item
            The state removal method requires a new kind of automaton which we would rather avoid.

        \pause
            
        \item
            We settled for Kleene's transitive closure method.
           
   \end{itemize}
\end{frame}

\end{document}
